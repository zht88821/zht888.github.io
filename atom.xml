<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zht88821.github.io</id>
    <title>zht的技术小站</title>
    <updated>2021-05-14T09:59:14.460Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zht88821.github.io"/>
    <link rel="self" href="https://zht88821.github.io/atom.xml"/>
    <subtitle>加油学习赚大钱！！！
</subtitle>
    <logo>https://zht88821.github.io/images/avatar.png</logo>
    <icon>https://zht88821.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, zht的技术小站</rights>
    <entry>
        <title type="html"><![CDATA[关于扫雷游戏的C语言代码实现与心得]]></title>
        <id>https://zht88821.github.io/post/guan-yu-sao-lei-you-xi-de-c-yu-yan-dai-ma-shi-xian-yu-xin-de/</id>
        <link href="https://zht88821.github.io/post/guan-yu-sao-lei-you-xi-de-c-yu-yan-dai-ma-shi-xian-yu-xin-de/">
        </link>
        <updated>2021-05-14T07:43:51.000Z</updated>
        <content type="html"><![CDATA[<p>扫雷相信大家都玩过吧，就是一个矩形方阵中有一些雷，你点到不是雷的位置，会显示周围一圈有几个雷，直到把所有非雷方格都点完，就算是游戏胜利了。<br>
在C语言中实现这个逻辑要怎么考虑呢？同样我们用到了数组，这次我们用两个数组来实现，一个用来存放雷的数组，一个用来存放显示给玩家棋盘游戏状态的数组，有了两个数组，我们要先初始化，打印棋盘，然后布置雷，扫雷，每一步判断一下是否胜利，进阶一下，我们可以设计一个函数实现：如果一个坐标不是雷，让周围不是雷的一大片一起消除，直到周围有雷为止；还可以设计做标记、第一步就踩雷的话重置雷等等。整体的逻辑就是这样，我们来实现一下。<br>
首先依然在VS编译器中创建一个扫雷游戏的项目，在项目里面创建text.c、game.c和game.h三个文件，分别用来存放游戏main函数及游戏流程、函数的实现、函数的声明。<br>
<img src="https://zht88821.github.io/post-images/1620978949791.png" alt="" loading="lazy"><br>
创建好后，我们首先要实现流程和main（）函数，main()函数就很简单的流程：<br>
<img src="https://zht88821.github.io/post-images/1620979211381.png" alt="" loading="lazy"><br>
main函数中的test()函数：<br>
<img src="https://zht88821.github.io/post-images/1620979318165.png" alt="" loading="lazy"><br>
函数中实现了游戏的流程，其中的srand是用来设置时间戳，为之后的随机取值做准备，menu（）函数的实现很简单：<br>
<img src="https://zht88821.github.io/post-images/1620979533001.png" alt="" loading="lazy"><br>
选择1进入游戏后，game函数是游戏的总流程，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620979618804.png" alt="" loading="lazy"><br>
其中的流程是，先创建数组，一个用来布置雷，一个用来排查雷，然后再用自定义的InitBoard（）函数用来初始化数组，SetMine（）用来布置雷，DisplayBoard()用来打印棋盘，最后FindMine() 用来扫雷和判断游戏状态。知道了大概流程，我们在game.h头文件中声明一下我们需要的这些函数：<br>
<img src="https://zht88821.github.io/post-images/1620979856624.png" alt="" loading="lazy"><br>
函数的意义图片上一一都注释出来了，引了三个头文件需要用，定义了五个常量后面都要用，这样定义常量，方便游戏后面修改棋盘的大小和雷的数量。到现在为止，game.h头文件和test.c测试文件都已经编辑好了，我们最后来编辑game.c文件，来实现声明的这些函数。<br>
InitBoard()初始化棋盘函数的实现：<br>
<img src="https://zht88821.github.io/post-images/1620980095024.png" alt="" loading="lazy"><br>
形参set用来指示初始化的字符，方便两个棋盘不同的初始化要求。<br>
DisplayBoard()打印棋盘函数的实现:<br>
<img src="https://zht88821.github.io/post-images/1620980214900.png" alt="" loading="lazy"><br>
SetMine（）布置雷函数的实现：<br>
<img src="https://zht88821.github.io/post-images/1620980411730.png" alt="" loading="lazy"><br>
定义的常量EASY_COUNT用来指定雷的数量，这时候rand()函数用来随机在棋盘中放置雷，rand() % row + 1 和 rand() % col + 1刚好在1-9范围内，符合我们要随机布置雷的要求。<br>
FindMine()排雷的函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620980919600.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620980926286.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620980931230.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620980936151.png" alt="" loading="lazy"><br>
排雷函数有点长，首先我们在一个大while循环中，用switch函数让我们选择，这里我设计了三个选项：1.排雷；2.做标记；3.取消标记；分别对应case1、case2、case3。   排雷中如果第一步就踩雷我们就重置雷，用rand()随机让一个不为雷的位置变成雷，而第一步踩到的雷变成了非雷，然后继续游戏，整形变量cnt用来存放非雷的数量，用来后面判断是否胜利,get_mine_count（)用来统计坐标周围雷的数量，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620982014989.png" alt="" loading="lazy"><br>
函数类型为int型，最后还要加一个'0'变成整形，原理去看ASCII码表🤣<br>
Clean（）函数用来一次性排除非雷位置周围所有非雷位置，直到展开到周围有雷为止，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620982575311.png" alt="" loading="lazy"><br>
函数的大概意思就是先判断非雷坐标周围八个坐标的周围八个坐标周围是否有雷，直到旁边有雷就停止，没有雷继续递归调用Clean()函数，实现一次展开大量非雷坐标，用count接收展开的格子数，后面cnt-count用来判断是否胜利。<br>
标记功能和取消标记功能的实现很简单，就不赘述了，还用了一个goto语句如果不是第一次踩雷，就跳转到end语句进行判断，整个游戏的实现就讲的差不多了。</p>
<p>运行结果：<br>
排雷：<br>
<img src="https://zht88821.github.io/post-images/1620983232606.png" alt="" loading="lazy"><br>
标记：<br>
<img src="https://zht88821.github.io/post-images/1620983252172.png" alt="" loading="lazy"><br>
取消标记：<br>
<img src="https://zht88821.github.io/post-images/1620983267291.png" alt="" loading="lazy"><br>
扫雷成功：<br>
<img src="https://zht88821.github.io/post-images/1620983471137.png" alt="" loading="lazy"><br>
被炸死了：<br>
<img src="https://zht88821.github.io/post-images/1620983521050.png" alt="" loading="lazy"><br>
我的心得讲完了，希望能帮助到大家！😄，具体的代码在我的github上：https://github.com/zht88821/C_CODE。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于三子棋游戏的C语言实现]]></title>
        <id>https://zht88821.github.io/post/guan-yu-san-zi-qi-you-xi-de-c-yu-yan-shi-xian/</id>
        <link href="https://zht88821.github.io/post/guan-yu-san-zi-qi-you-xi-de-c-yu-yan-shi-xian/">
        </link>
        <updated>2021-05-13T12:58:03.000Z</updated>
        <content type="html"><![CDATA[<p>最近学到了三子棋游戏的C语言实现，在这里我写一写我自己的心得吧！😄<br>
什么是三子棋呢，简单来说，就是上学时候经常在本子上画来画去的井字棋，<br>
只要横着、竖着或者斜着三个相同的子连成一条线，就算游戏胜利，两个玩家参与，采用回合制。规则是不是很简单呢？现在我们来谈一下，如果要在C语言中实现，要考虑哪些问题呢，首先要考虑的是棋盘上下棋的信息怎么保存，刚学过数组，我们就用3*3的二维数组来保存我们棋子的信息，棋盘的打印就封装一个函数来实现，棋盘在没下之前要‘清空’，所以我们还得封装一个初始化二维数组的函数， 下棋的时候就下在二维数组的对应位置，玩家下棋得封装一个函数，电脑下棋的函数要实现随机，每下完一步还得判断下是否有输赢，或者平局。大致的思路就是这样，现在我们来开始实现代码。<br>
我们首先先在vs编译器上创建一个项目，创建一个test.c源文件，用作测试；一个game.c源文件，用于代码的具体实现；一个game.h头文件，用于函数的声明。大概是这样：<br>
<img src="https://zht88821.github.io/post-images/1620911963182.png" alt="" loading="lazy"><br>
我们要写test.c文件，把整个程序的执行流程写下来：<br>
<img src="https://zht88821.github.io/post-images/1620912080449.png" alt="" loading="lazy"><br>
封装了一个test（）函数，test()函数的实现为：<br>
<img src="https://zht88821.github.io/post-images/1620912148392.png" alt="" loading="lazy"><br>
先进入游戏，先打印菜单，封装一个菜单函数：<br>
<img src="https://zht88821.github.io/post-images/1620912332321.png" alt="" loading="lazy"><br>
接下来就进入游戏流程了，输入1，进入游戏：<br>
<img src="https://zht88821.github.io/post-images/1620912601654.png" alt="" loading="lazy"><br>
游戏的流程在图片中说明了，其中封装的函数在game.h头文件中也声明了<br>
<img src="https://zht88821.github.io/post-images/1620913024438.png" alt="" loading="lazy"><br>
函数的大概意思也注释了，还定义两个常量ROW、COL，方便棋盘大小的更改，引入三个头文件会在后面用到。InitBoard()函数的实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620913254665.png" alt="" loading="lazy"><br>
DisplayBoard()函数的实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620913323916.png" alt="" loading="lazy"><br>
井字棋的打印的要点是分组将数据行和分割行循环打印大概这样分组：<br>
<img src="https://zht88821.github.io/post-images/1620914323338.png" alt="" loading="lazy"><br>
就这样打印一行数据，打印一行分割行，再设置条件每行数据和分割行的最后一个竖杠不用打印，而且分割行只需打印row-1行。数据行相当于:   |   |   |,最后一个|不用打；分割行相当于:---|---|---|,同理最后一个|不用打，这样就好设置条件完成棋盘的打印了。<br>
PlayerMove函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620973958678.png" alt="" loading="lazy"><br>
大致就是判断输入的坐标是否合法，合法的话就存在数组里。<br>
ComputerMove函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620974287867.png" alt="" loading="lazy"><br>
用rand()函数实现电脑随机走棋。<br>
每次玩家或者电脑走完棋之后还要判断下游戏的状态，封装了IsWin函数，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620974610165.png" alt="" loading="lazy"><br>
判断横三行，竖三行和两个对角线是否相等且不为空，如果没有就判断棋盘是否满了，封装了一个IsFull函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620974949634.png" alt="" loading="lazy"><br>
如果都不满足，则继续游戏。<br>
游戏运行结果如下：<br>
玩家赢的情况：<br>
<img src="https://zht88821.github.io/post-images/1620976259624.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620976267423.png" alt="" loading="lazy"><br>
电脑赢的情况：<br>
<img src="https://zht88821.github.io/post-images/1620976495695.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620976503782.png" alt="" loading="lazy"><br>
平局的情况:<br>
<img src="https://zht88821.github.io/post-images/1620976820759.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620976833394.png" alt="" loading="lazy"></p>
<p>这个游戏的讲解到这里了，具体的代码实现到我的github上有：https://github.com/zht88821/C_CODE，希望能帮到大家！😀</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言-数组-冒泡排序及数组传参的用法]]></title>
        <id>https://zht88821.github.io/post/c-yu-yan-shu-zu-mou-pao-pai-xu-ji-shu-zu-chuan-can-de-yong-fa/</id>
        <link href="https://zht88821.github.io/post/c-yu-yan-shu-zu-mou-pao-pai-xu-ji-shu-zu-chuan-can-de-yong-fa/">
        </link>
        <updated>2021-05-10T09:03:41.000Z</updated>
        <content type="html"><![CDATA[<p>在学习了数组的有关知识后，和B站教学视频一起码了个冒泡排序，啥是冒泡排序呢？很简单，就是将一个数组按照升/降序排列，很简单的一个小问题，直接上代码：<br>
<img src="https://zht88821.github.io/post-images/1620638475146.png" alt="" loading="lazy"><br>
在代码里定义了一个bubble_sort函数，这里是用来将数组按升序排序的，数组的个数sz的计算之所以不能在函数中，是因为数组名传参只是传过去首元素的地址，在函数中使用sizeof运算符不能计算出正确的数组个数，所以在   main函数中提前将sz算出，然后作为函数参数输入，这里继续提一句，一般来说数组名传参代表首元素的地址，但有两种特殊情况：①在sizeof(数组名)的时候，数组名代表整个数组；②&amp;数组名 代表的是整个数组的地址。<br>
函数中设置了flag，防止在数组已经有序的情况下，进行多余的运算。<br>
此代码的运行结果：<br>
<img src="https://zht88821.github.io/post-images/1620638127505.png" alt="" loading="lazy"><br>
冒泡排序啰嗦到这了，希望能帮到大家！😁</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[小青蛙跳台阶问题的心得]]></title>
        <id>https://zht88821.github.io/post/xiao-qing-wa-tiao-tai-jie-wen-ti-de-xin-de/</id>
        <link href="https://zht88821.github.io/post/xiao-qing-wa-tiao-tai-jie-wen-ti-de-xin-de/">
        </link>
        <updated>2021-05-08T13:50:57.000Z</updated>
        <content type="html"><![CDATA[<p>今天简单研究了下小青蛙问题，类似于斐波那契数列，废话不多说，现在来总结一下这个问题！<br>
我把小青蛙问题分成成两个模块，一个是简单版，一个是进阶版，我们先来讲讲简单版本的小青蛙问题：有一只小青蛙一次能跳1个台阶或者2个台阶，如果台阶一共有n个，问小青蛙总共有多少种跳法？ 先从最简单的问题入手，如果n=1的时候，，小青蛙一共只能选择（1）这1种跳法，如果n=2的时候，小青蛙可以选择（1,1）或者（2）这2种跳法，那么n=3的时候，小青蛙可以选择（1,1,1）、（1,2）、（2,1）3种跳法，n=4的时候可以选择（1,1,1,1)、（1,1,2)、(1,2,1)、(2,2)、(2,1,1)五种，为了方便理解，我们把小青蛙问题看成一个函数：f(n)=n级台阶小青蛙能够选择的跳法总数，根据前面简单列举的几种情况，能发现一点简单的规律，比如：f(3)=f(2)+f(1)、f(4)=f(3)+f(2)。但是研究问题是要严谨的，不能这么随意的就下结论，我们来继续研究一下，当n很大的时候，最后一步无非就只有两种情况：最后一步还剩下1个台阶或者最后一步还剩下2个台阶。  把问题想到这里，就感觉豁然开朗了，最后一步剩下1个台阶的方法数就是f(n-1)，最后一步剩下2个台阶的方法数就是f(n-2),那么就得出我们的推论：      f(n)=f(n-1)+f(n-2),事实上的定论和我们的推论是一样的，在知道了原理，现在我们可以来开始用C语言实现这个问题啦！<br>
<img src="https://zht88821.github.io/post-images/1620482199987.png" alt="" loading="lazy"><br>
在图中jump1函数是用函数递归的方式实现这个问题的，已知最简单的n=1和n=2的时候直接返回种类，将n =1和 n=2设置为递归的出口，在n&gt;2的时候用了公式f(n)=f(n-1)+f(n-2),实现了这个游戏，但是用函数递归的方法可以发现，f(n)=f(n-1)+f(n-2) , 其中的f(n-1)递归成f(n-2)+f(n-3), 其中的f(n-2)又递归成f(n-3)+f(n-4)，可以发现计算中需要大量重复计算相同的值，计算存在大量的冗余，当n的值非常大时 ，计算的效率很低很低，那有什么办法解决呢？<br>
解决办法就是图中的jump2函数，用循环方式解决了计算的大量冗余，使计算不存在冗余，大大提高计算速度。for循环中运用了三个整形变量a,b,c，当n = 1时直接输出1种，当n&gt;=2时，使a+b的值赋给c，b赋给a,c赋给b，循环往复，实现了数值的变化，跳出for循环后在最后返回c。当n=6的时候程序的运行结果如下：<br>
<img src="https://zht88821.github.io/post-images/1620482341731.png" alt="" loading="lazy"><br>
此时小青蛙问题的简易版就解决啦，接下来可以挑战进阶版了😀<br>
那么什么是小青蛙问题的进阶版呢？就是把问题稍微改一下，假设有n个台阶，小青蛙现在可以一次跳1个台阶、一次跳2个台阶、一次跳3个台阶...一次跳n个台阶，请问小青蛙共有多少种跳法呢？是不是感觉难一点了呢，把这个问题弄懂，小青蛙问题应该就没问题了吧，现在我们来讨论一下这个问题？<br>
如果是这样，那么一共有多少种跳法呢？其实思路和简单版的一样，我们可以在最后一步剩余不同的台阶个数，在跳到最后一步只剩余一格的时候，最后一步留有一格的情况下有f(n-1)种，类似的在最后一步只剩余两格的时候有f(n-2种，以此类推，所以f(n)=f(n-1)+f(n-2)+....+f(1)+1,加1是因为可以直接一步跳完，我们又可以发现f(n-1)=f(n-2)+f(n-3)+...+f(1)+1, 所以f(n) = 2*f(n-1)，在理清了思路后我们就可以用C语言来实现啦！下面是C语言实现：<br>
<img src="https://zht88821.github.io/post-images/1620483876997.png" alt="" loading="lazy"><br>
函数jump_adv就是解决进阶版问题的函数了，这里直接用循环方式了，不写递归方式了，因为循环方式比递归方式更优，函数里设置了整形变量sum和a，sum用来计算公式f(n)=f(n-1)+f(n-2)+...+f(1)+1的累加和，a是初始值，sum将即将改变的值赋给a和sum每次加上新的a的值实现函数，详细的解析写在图片里了。当n=6时，程序执行的结果如下：<br>
<img src="https://zht88821.github.io/post-images/1620484153734.png" alt="" loading="lazy"><br>
到现在为止，小青蛙跳台阶的问题算是讲清楚了，如果能帮到你，那是我的荣幸，很高兴分享自己的心得😋！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汉诺塔游戏的心得]]></title>
        <id>https://zht88821.github.io/post/han-nuo-ta-you-xi-de-xin-de/</id>
        <link href="https://zht88821.github.io/post/han-nuo-ta-you-xi-de-xin-de/">
        </link>
        <updated>2021-05-07T13:52:04.000Z</updated>
        <content type="html"><![CDATA[<p>从昨天到现在的碎片时间研究了下汉诺塔游戏的c语言实现，看到鹏哥c语言中提到了这个，就来试着自己学一学，刚学到递归调用，汉诺塔也算是一个递归调用的经典例题，刚好来巩固一下所学的知识，一开始谷歌了下网上的文档，内容不怎么容易懂，没怎么搞清楚，然后在B站找了个视频看，现在终于弄得差不多懂了，来分享一下自己的想法。<br>
先来简单介绍一下汉诺塔游戏，我直接谷歌了一下简介：汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。简单来说就是有三根柱子A、B、C,在A上有若干个从下往上逐渐变小的圆盘，要从柱子A借助柱子B转移到柱子C，规则就是：①一次只能转移一个圆盘。②较大的圆盘不能放在较小的圆盘上。<img src="https://zht88821.github.io/post-images/1620396589941.jfif" alt="" loading="lazy">  如果只是让你直接操作应该也不算难，如果在c语言上实现呢?<br>
这个游戏算法在c语言中实现需要用到函数递归，要用到递归，那么首先需要把一个大的问题分解成一个小的步骤，然后能重复调用这个步骤接近结果，直到执行结束。<img src="https://zht88821.github.io/post-images/1620396955102.png" alt="" loading="lazy">分解步骤我在B站看的视频里已经写的很明白了，我就直接借用这张图来描述了。图中把整个过程分成了三步，其中第一步和第三步又可以各自看成一次汉诺塔游戏，递归调用重复这三个步骤，递归的出口就是只剩下一个盘子的时候把最后一个盘子移到目的杆子上。<br>
借助这个思想，就可以在编译器上来实现<img src="https://zht88821.github.io/post-images/1620397429887.png" alt="" loading="lazy"><br>
假设有3个盘子的时候，程序的执行结果：<img src="https://zht88821.github.io/post-images/1620397541028.png" alt="" loading="lazy"><br>
汉诺塔游戏的心得到这里了，如果能帮到大家，是我的荣幸😀！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World!!!]]></title>
        <id>https://zht88821.github.io/post/hello-world/</id>
        <link href="https://zht88821.github.io/post/hello-world/">
        </link>
        <updated>2021-04-29T10:07:24.000Z</updated>
        <content type="html"><![CDATA[<p>忙活了几天终于把属于自己的博客创建起来了😋，也是我第一次写博客，作为未来的IT新星，我会在这里分享我学习的经验，希望能和大家一起交流学习，能一起进步！😀 顺便记录下自己成长的历程和阶段，希望成为一个非常厉害的程序员，希望能赚大钱，加油！ 千里之行始于足下，每天的积累至关重要，坚持学习将是我最厉害的武器！</p>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zht88821.github.io</id>
    <title>zht的技术小站</title>
    <updated>2021-05-08T14:44:25.487Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zht88821.github.io"/>
    <link rel="self" href="https://zht88821.github.io/atom.xml"/>
    <subtitle>加油学习赚大钱！！！
</subtitle>
    <logo>https://zht88821.github.io/images/avatar.png</logo>
    <icon>https://zht88821.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, zht的技术小站</rights>
    <entry>
        <title type="html"><![CDATA[小青蛙跳台阶问题的心得]]></title>
        <id>https://zht88821.github.io/post/xiao-qing-wa-tiao-tai-jie-wen-ti-de-xin-de/</id>
        <link href="https://zht88821.github.io/post/xiao-qing-wa-tiao-tai-jie-wen-ti-de-xin-de/">
        </link>
        <updated>2021-05-08T13:50:57.000Z</updated>
        <content type="html"><![CDATA[<p>今天简单研究了下小青蛙问题，类似于斐波那契数列，废话不多说，现在来总结一下这个问题！<br>
我把小青蛙问题分成成两个模块，一个是简单版，一个是进阶版，我们先来讲讲简单版本的小青蛙问题：有一只小青蛙一次能跳1个台阶或者2个台阶，如果台阶一共有n个，问小青蛙总共有多少种跳法？ 先从最简单的问题入手，如果n=1的时候，，小青蛙一共只能选择（1）这1种跳法，如果n=2的时候，小青蛙可以选择（1,1）或者（2）这2种跳法，那么n=3的时候，小青蛙可以选择（1,1,1）、（1,2）、（2,1）3种跳法，n=4的时候可以选择（1,1,1,1)、（1,1,2)、(1,2,1)、(2,2)、(2,1,1)五种，为了方便理解，我们把小青蛙问题看成一个函数：f(n)=n级台阶小青蛙能够选择的跳法总数，根据前面简单列举的几种情况，能发现一点简单的规律，比如：f(3)=f(2)+f(1)、f(4)=f(3)+f(2)。但是研究问题是要严谨的，不能这么随意的就下结论，我们来继续研究一下，当n很大的时候，最后一步无非就只有两种情况：最后一步还剩下1个台阶或者最后一步还剩下2个台阶。  把问题想到这里，就感觉豁然开朗了，最后一步剩下1个台阶的方法数就是f(n-1)，最后一步剩下2个台阶的方法数就是f(n-2),那么就得出我们的推论：      f(n)=f(n-1)+f(n-2),事实上的定论和我们的推论是一样的，在知道了原理，现在我们可以来开始用C语言实现这个问题啦！<br>
<img src="https://zht88821.github.io/post-images/1620482199987.png" alt="" loading="lazy"><br>
在图中jump1函数是用函数递归的方式实现这个问题的，已知最简单的n=1和n=2的时候直接返回种类，将n =1和 n=2设置为递归的出口，在n&gt;2的时候用了公式f(n)=f(n-1)+f(n-2),实现了这个游戏，但是用函数递归的方法可以发现，f(n)=f(n-1)+f(n-2) , 其中的f(n-1)递归成f(n-2)+f(n-3), 其中的f(n-2)又递归成f(n-3)+f(n-4)，可以发现计算中需要大量重复计算相同的值，计算存在大量的冗余，当n的值非常大时 ，计算的效率很低很低，那有什么办法解决呢？<br>
解决办法就是图中的jump2函数，用循环方式解决了计算的大量冗余，使计算不存在冗余，大大提高计算速度。for循环中运用了三个整形变量a,b,c，当n = 1时直接输出1种，当n&gt;=2时，使a+b的值赋给c，b赋给a,c赋给b，循环往复，实现了数值的变化，跳出for循环后在最后返回c。当n=6的时候程序的运行结果如下：<br>
<img src="https://zht88821.github.io/post-images/1620482341731.png" alt="" loading="lazy"><br>
此时小青蛙问题的简易版就解决啦，接下来可以挑战进阶版了😀<br>
那么什么是小青蛙问题的进阶版呢？就是把问题稍微改一下，假设有n个台阶，小青蛙现在可以一次跳1个台阶、一次跳2个台阶、一次跳3个台阶...一次跳n个台阶，请问小青蛙共有多少种跳法呢？是不是感觉难一点了呢，把这个问题弄懂，小青蛙问题应该就没问题了吧，现在我们来讨论一下这个问题？<br>
如果是这样，那么一共有多少种跳法呢？其实思路和简单版的一样，我们可以在最后一步剩余不同的台阶个数，在跳到最后一步只剩余一格的时候，最后一步留有一格的情况下有f(n-1)种，类似的在最后一步只剩余两格的时候有f(n-2种，以此类推，所以f(n)=f(n-1)+f(n-2)+....+f(1)+1,加1是因为可以直接一步跳完，我们又可以发现f(n-1)=f(n-2)+f(n-3)+...+f(1)+1, 所以f(n) = 2*f(n-1)，在理清了思路后我们就可以用C语言来实现啦！下面是C语言实现：<br>
<img src="https://zht88821.github.io/post-images/1620483876997.png" alt="" loading="lazy"><br>
函数jump_adv就是解决进阶版问题的函数了，这里直接用循环方式了，不写递归方式了，因为循环方式比递归方式更优，函数里设置了整形变量sum和a，sum用来计算公式f(n)=f(n-1)+f(n-2)+...+f(1)+1的累加和，a是初始值，sum将即将改变的值赋给a和sum每次加上新的a的值实现函数，详细的解析写在图片里了。当n=6时，程序执行的结果如下：<br>
<img src="https://zht88821.github.io/post-images/1620484153734.png" alt="" loading="lazy"><br>
到现在为止，小青蛙跳台阶的问题算是讲清楚了，如果能帮到你，那是我的荣幸，很高兴分享自己的心得😋！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汉诺塔游戏的心得]]></title>
        <id>https://zht88821.github.io/post/han-nuo-ta-you-xi-de-xin-de/</id>
        <link href="https://zht88821.github.io/post/han-nuo-ta-you-xi-de-xin-de/">
        </link>
        <updated>2021-05-07T13:52:04.000Z</updated>
        <content type="html"><![CDATA[<p>从昨天到现在的碎片时间研究了下汉诺塔游戏的c语言实现，看到鹏哥c语言中提到了这个，就来试着自己学一学，刚学到递归调用，汉诺塔也算是一个递归调用的经典例题，刚好来巩固一下所学的知识，一开始谷歌了下网上的文档，内容不怎么容易懂，没怎么搞清楚，然后在B站找了个视频看，现在终于弄得差不多懂了，来分享一下自己的想法。<br>
先来简单介绍一下汉诺塔游戏，我直接谷歌了一下简介：汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。简单来说就是有三根柱子A、B、C,在A上有若干个从下往上逐渐变小的圆盘，要从柱子A借助柱子B转移到柱子C，规则就是：①一次只能转移一个圆盘。②较大的圆盘不能放在较小的圆盘上。<img src="https://zht88821.github.io/post-images/1620396589941.jfif" alt="" loading="lazy">  如果只是让你直接操作应该也不算难，如果在c语言上实现呢?<br>
这个游戏算法在c语言中实现需要用到函数递归，要用到递归，那么首先需要把一个大的问题分解成一个小的步骤，然后能重复调用这个步骤接近结果，直到执行结束。<img src="https://zht88821.github.io/post-images/1620396955102.png" alt="" loading="lazy">分解步骤我在B站看的视频里已经写的很明白了，我就直接借用这张图来描述了。图中把整个过程分成了三步，其中第一步和第三步又可以各自看成一次汉诺塔游戏，递归调用重复这三个步骤，递归的出口就是只剩下一个盘子的时候把最后一个盘子移到目的杆子上。<br>
借助这个思想，就可以在编译器上来实现<img src="https://zht88821.github.io/post-images/1620397429887.png" alt="" loading="lazy"><br>
假设有3个盘子的时候，程序的执行结果：<img src="https://zht88821.github.io/post-images/1620397541028.png" alt="" loading="lazy"><br>
汉诺塔游戏的心得到这里了，如果能帮到大家，是我的荣幸😀！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World!!!]]></title>
        <id>https://zht88821.github.io/post/hello-world/</id>
        <link href="https://zht88821.github.io/post/hello-world/">
        </link>
        <updated>2021-04-29T10:07:24.000Z</updated>
        <content type="html"><![CDATA[<p>忙活了几天终于把属于自己的博客创建起来了😋，也是我第一次写博客，作为未来的IT新星，我会在这里分享我学习的经验，希望能和大家一起交流学习，能一起进步！😀 顺便记录下自己成长的历程和阶段，希望成为一个非常厉害的程序员，希望能赚大钱，加油！ 千里之行始于足下，每天的积累至关重要，坚持学习将是我最厉害的武器！</p>
]]></content>
    </entry>
</feed>
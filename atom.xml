<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zht88821.github.io</id>
    <title>zht的技术小站</title>
    <updated>2021-06-01T09:34:23.383Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zht88821.github.io"/>
    <link rel="self" href="https://zht88821.github.io/atom.xml"/>
    <subtitle>加油学习赚大钱！！！
</subtitle>
    <logo>https://zht88821.github.io/images/avatar.png</logo>
    <icon>https://zht88821.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, zht的技术小站</rights>
    <entry>
        <title type="html"><![CDATA[C语言---指针进阶的相关心得]]></title>
        <id>https://zht88821.github.io/post/c-yu-yan-zhi-zhen-jin-jie-de-xiang-guan-xin-de/</id>
        <link href="https://zht88821.github.io/post/c-yu-yan-zhi-zhen-jin-jie-de-xiang-guan-xin-de/">
        </link>
        <updated>2021-06-01T01:14:22.000Z</updated>
        <content type="html"><![CDATA[<p>最近几天深度学习了下指针，收获了不少，在此记录一下所学的知识。</p>
<p>之前也写了一下指针的基本知识，下面继续介绍更高级的知识：<br>
<img src="https://zht88821.github.io/post-images/1622510751878.png" alt="" loading="lazy"></p>
<p>我主要进行字符指针、数组指针、指针数组、数组和指针传参、函数指针、函数指针数组、指向函数数组的指针、回调函数来讲解。</p>
<p>一、字符指针<br>
我首先从字符指针开始讲，字符指针就是char*型的指针，一般使用就是将字符指针指向一个字符的地址  如下：<br>
<img src="https://zht88821.github.io/post-images/1622510838892.png" alt="" loading="lazy"><br>
还可以将字符指针指向一个常量字符串，这时候字符指针实质上是指向了字符串首字符的地址：<br>
<img src="https://zht88821.github.io/post-images/1622511148704.png" alt="" loading="lazy"><br>
现在来看看下面一串代码:<br>
<img src="https://zht88821.github.io/post-images/1622511237146.png" alt="" loading="lazy"><br>
str3和str4指向同一个常量字符串，指向同一块内存，但是用相同的字符串初始化不同的数组时就会开辟不同的空间，所以str1和str2不同，str3和str4相同。</p>
<p>二、指针数组<br>
指针数组就是一个数组，数组的每个元素是同一个指针类型。比如 int* p[5] 、char * pp[5]。<br>
<img src="https://zht88821.github.io/post-images/1622511453102.png" alt="" loading="lazy"></p>
<p>三、数组指针<br>
数组指针是一个指针，我们知道整型指针int* p能够指向整型数据，浮点型指针float* pf能够指向浮点型数据，那么数组指针就是能够指向数组的指针。<br>
数组指针的写法是:int (*p)[10]，这个例子的意思是p和 *先结合表示p是一个指针变量，指向的是一个大小为10个整型的数组。<br>
<img src="https://zht88821.github.io/post-images/1622511867840.png" alt="" loading="lazy"><br>
在这里拓展一下数组名和&amp;数组名的区别：<br>
<img src="https://zht88821.github.io/post-images/1622512122120.png" alt="" loading="lazy"><br>
通过打印int arr[10]的数组名和&amp;数组名，我们发现打印出来的值是相等的，但是这两个地址在本质上是有区别的，不信来看看下面的打印：<br>
<img src="https://zht88821.github.io/post-images/1622512199933.png" alt="" loading="lazy"><br>
我们发现&amp;arr和arr的值虽然相等，但是意义不一样，&amp;arr表示整个数组的地址，数组的地址+1跳过整个数组大小，而arr代表数组首元素的地址，数组首元素地址+1代表跳过一个整型的地址。<br>
数组指针可以用来在函数中接收一个二维数组数组名，我们知道数组名表示首元素地址，而二维数组的首元素是二维数组的第一行的地址，相当于是一个一维数组地址，比如int arr[3][5]，arr代表首元素地址，相当于是arr[0],arr[0]是一个一维数组，数组有5个整型元素。  实例如图：<br>
<img src="https://zht88821.github.io/post-images/1622513025978.png" alt="" loading="lazy"><br>
下面四行代码分别代表什么呢？<br>
int arr[5];//是一个有五个元素的整型数组<br>
int *parr1[10];//是一个有10个元素的整型指针数组<br>
int (*parr2)[10];//是一个数组指针，指向一个有10个元素的整型数组<br>
int (*parr3[10])[5];//首先parr3和[]结合，说明它是一个数组，数组有10个元素，  每个元素是int ( * )[5]的数组指针，指向一个有五个元素的整型数组的指针。</p>
<p>四、数组、指针传参<br>
在写代码的时候难免要把数组或者指针传给函数，那么函数的参数该如何设计呢？<br>
一维数组传参：<br>
<img src="https://zht88821.github.io/post-images/1622513521104.png" alt="" loading="lazy"><br>
一维数组传参时，参数可以设计成用数组来接收，也可以用指针来接收。</p>
<p>二维数组传参：<br>
<img src="https://zht88821.github.io/post-images/1622513711562.png" alt="" loading="lazy"><br>
二维数组传参时，参数可以设计成用数组来接收，也可以用指针来接收。需要注意的是，用数组来接收的时候，数组的第二个方块里的内容也就是列 不可以省略，如果用指针来接受，需要使用数组指针。</p>
<p>一级指针传参：<br>
<img src="https://zht88821.github.io/post-images/1622514088606.png" alt="" loading="lazy"><br>
思考一个问题：当函数形参为一个一级指针时，实参可以传什么?<br>
<img src="https://zht88821.github.io/post-images/1622514180399.png" alt="" loading="lazy"></p>
<p>二级指针传参：<br>
<img src="https://zht88821.github.io/post-images/1622514388688.png" alt="" loading="lazy"><br>
思考一个问题：当函数形参为一个二级指针时，实参可以传什么？<br>
<img src="https://zht88821.github.io/post-images/1622514456573.png" alt="" loading="lazy"></p>
<p>五、函数指针<br>
什么是函数指针呢？顾名思义就是一个指针，指针中保存着函数的地址，指针指向的是一个函数，那么我们讨论下函数的地址是什么呢？我们先来看一段代码：<br>
<img src="https://zht88821.github.io/post-images/1622533205311.png" alt="" loading="lazy"><br>
以上代码将函数名和&amp;函数名以地址的形式打印出来，我们可以看到两种方式打印出的结果是一样的，所以可以得出函数名和&amp;函数名都是函数的地址，那么我们怎么将函数地址保存在指针中呢？<br>
标准的写法是：void （ * p）(int,int),正确的解读是变量p先和 * 结合表示是一个指针，指针指向一个函数，函数的返回类型是void,函数有两个参数分别为int , int。代码实例：<br>
<img src="https://zht88821.github.io/post-images/1622533715719.png" alt="" loading="lazy"><br>
当要调用函数指针时，可以直接指针名＋（参数 ）或者 * 指针名 + （参数），两者的作用是一样的，程序的执行结果为：<br>
<img src="https://zht88821.github.io/post-images/1622533803055.png" alt="" loading="lazy"><br>
接着我们来阅读两段有趣的代码：<br>
<img src="https://zht88821.github.io/post-images/1622533891885.png" alt="" loading="lazy"><br>
代码1感觉有点复杂，我们怎么来解读呢？先将里面的void( * )( )看成一个函数指针类型，指向的函数是无参的，返回类型是void，接着我们发现这个类型将常量0强制类型转换为这个指针类型，然后再调用这个指针指向的函数，这么一解读是不是感觉容易理解了一些呢？<br>
代码2好像更加复杂，那我们怎么解读呢？首先我们将代码2化简：<br>
<img src="https://zht88821.github.io/post-images/1622534090243.png" alt="" loading="lazy"><br>
先将void(*)(int)这个函数指针重命名为pfun_t，化简之后的代码变成了                        pfun_t signal( int ,pfun_t),我们很容易的就看出了这是一个函数声明，函数名为signal,函数的返回类型是一个函数指针，函数有两个参数类型，一个是int型, 一个是函数指针类型，这样看立马就一目了然了。</p>
<p>六、函数指针数组<br>
数组是一个存放相同类型数据的存储空间，那么什么是函数指针数组呢，其实就是一个数组，数组的每个元素都是一个函数指针，实质上就是将函数的地址存到一个数组中。那么函数指针数组该如何表达呢？<br>
标准的写法是：int(<em>parr[10])(int,int)，将这个例子解读为变量parr先和[ ]结合，因为[ ]的优先级大于   * ， parr[10]表示一个数组，有十个元素，每个元素的类型是int(</em>)(int,int)类型的函数指针，函数指针指向的函数的返回类型是int，指向的函数的参数类型为（int,int）。<br>
函数指针数组的用途是：转移表。代码实例：<br>
<img src="https://zht88821.github.io/post-images/1622534920370.png" alt="" loading="lazy"><br>
代码中变量p是一个函数指针数组，存放了具有相同返回类型，相同参数类型的四个函数地址，有效减少了代码的冗余，使代码清爽简短。</p>
<p>七、指向函数指针数组的指针<br>
是不是感觉很复杂？我第一次读的时候也绕晕了，我们先来捋一捋，其实指向函数指针数组的指针，实质上是一个指针，指针指向一个数组，数组的元素是函数指针类型。其实也不是很复杂。那么如何来定义这个指针呢？来看下面的代码：<br>
<img src="https://zht88821.github.io/post-images/1622535851738.png" alt="" loading="lazy"><br>
代码中的变量ppfunArr就是一个指向函数指针数组的指针，ppfunArr先和* 结合，说明它是一个指针，指针指向一个数组，数组有10个元素，每个元素是一个void( * )(const char*)类型的函数指针。</p>
<p>八、回调函数<br>
什么是回调函数呢？简单来讲回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就称被调用的函数为回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。<br>
首先我们来介绍一下qsort库函数，它是一个快速排序函数，将一个数组从小到大进行顺序排序，那么qsort函数的参数是什么呢？<br>
qsort 的函数原型是void qsort<br>
(void<em>base,//待排序数组的首元素地址<br>
size_t num,//待排序数组的元素个数<br>
size_t width,//待排序数组的每个元素的大小 - 单位是字节<br>
int( *  compare)(const void</em>,const void*))//是函数指针，比较两个元素的函数的地址 - 由函数使用者自己实现</p>
<p>在qsort函数中，有四个参数，最后一个参数是一个函数指针，指向一个比较两个元素的函数的地址，这个函数需要由使用者自己实现，这个被调用的函数就被称为回调函数。<br>
在函数中出现了void*这个类型，这个类型是干嘛的呢？void  * 可以接收任何指针类型，但是不能进行解引用操作，不能进行指针+-整数操作，但是可以将这个指针变量强制类型转换为别的类型的指针，进行解引用操作，所以说，void * 的灵活性很大，通常可以适应于很多的函数声明。<br>
<img src="https://zht88821.github.io/post-images/1622536843749.png" alt="" loading="lazy"></p>
<p>下面我自己用代码实现了qsort的自制版<br>
<img src="https://zht88821.github.io/post-images/1622536928527.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1622536936461.png" alt="" loading="lazy"><br>
bubble_sort是自己声明的一个函数，函数的参数和qsort的一模一样，void* base可以使不同类型的数组首元素地址可以传进来，最后一个参数是函数指针，指向一个比较函数，比较函数的参数是        void  * ,void  * ，可以灵活的自定义比较函数中需要传过来的参数的类型。<br>
在两个元素比较的过程中，将void* base强制类型转换为char*,因为参数中也给了数组中每个元素的字节数width，width*j ，因为char *的权限是一次移动一个字节，移动width个字节刚好跳过一个元素，这样就可以访问后续的元素。<br>
交换函数中，参数设置为char * ，也可以一个字节一个字节的交换两个元素的值，交换width次，就实现了两个元素的交换。</p>
<p>以上就是指针进阶的相关内容，如果能帮到你，属实万幸😁！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之数据的存储     学习心得]]></title>
        <id>https://zht88821.github.io/post/c-yu-yan-zhi-shu-ju-de-cun-chu-xue-xi-xin-de/</id>
        <link href="https://zht88821.github.io/post/c-yu-yan-zhi-shu-ju-de-cun-chu-xue-xi-xin-de/">
        </link>
        <updated>2021-05-24T15:29:18.000Z</updated>
        <content type="html"><![CDATA[<p>今天将数据存储的知识学习了下，来写点东西巩固一下自己所学的知识。<br>
在C语言中，有许多的内置数据类型，就是本来就定义好的数据类型，比如：<br>
<img src="https://zht88821.github.io/post-images/1621870493006.png" alt="" loading="lazy"><br>
数据类型的归类可以分为：整型、浮点型、构造类型、指针类型、空类型。<br>
<img src="https://zht88821.github.io/post-images/1621870711930.png" alt="" loading="lazy"><br>
整型又可分为 char、short、int、long，浮点型可分为float和double，构造类型可分为数组、结构体、枚举和联合类型，指针也有许多种类型。</p>
<p>先来谈谈整型在内存中是如何存储的，先引入三个表示概念：原码，反码，补码，这三种码都是有符号位和数值位的，最高位代表符号位，0为正数，1为负数。原码是直接将整型翻译成二进制就行。    反码就是在原码的基础上符号位不变，其余为取反。    补码就是反码+1。 在整型中，正数的原、反、补码都相同，只有负数的原、反、补码都不同，对于整型，在内存中存储的是补码，这样规定的原因是，使用补码可以将符号位和数值位统一处理，同时加法减法也可以统一处理。<br>
<img src="https://zht88821.github.io/post-images/1621871388286.png" alt="" loading="lazy"><br>
在知道了整型的原反补码，在编译器中查看一个整型在内存中的存储方式如图：<br>
<img src="https://zht88821.github.io/post-images/1621871674189.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1621872062727.png" alt="" loading="lazy"><br>
经过编译，发现内存中确实存的是16进制补码，但是仔细一看好像又有点不太对劲，在内存中怎么是倒过来记录的呢？20的十六进制为0x00000014，14为低地址，而图中在内存中低地址的地方也是14，虽然看着是倒着的，但是其实是低地址放在内存低地址处，这里有引出内存的存储的大小端机制。</p>
<figure data-type="image" tabindex="1"><img src="https://zht88821.github.io/post-images/1621872265036.png" alt="" loading="lazy"></figure>
<p>大端存储模式就是数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中。<br>
小端存储模式刚好相反。</p>
<p>现在来讲浮点数在内存中的存储方式，先来看看下面这个程序及输出结果：<br>
<img src="https://zht88821.github.io/post-images/1621873180471.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1621873188374.png" alt="" loading="lazy"><br>
为啥用浮点型取整数和用整数取浮点数，打印出来的数字这么奇怪呢？ 我们首先得了解浮点数在计算机内部的存储方式。根据国际标准IEEE（电气和电子工程协会） 754中规定了任意二进制浮点数，可以表示为如下图所示：<br>
<img src="https://zht88821.github.io/post-images/1621873398975.png" alt="" loading="lazy"><br>
对于其中的s,M,E在内存中是这样保存的：<br>
<img src="https://zht88821.github.io/post-images/1621873512790.png" alt="" loading="lazy"><br>
IEEE 754中规定了float(32位)、double（64)位在内存中的存储方式。IEEE 754标准对有效数字M和和指数E，还有一些特别的规定。因为1&lt;=M&lt; 2,所以M的形式是1.xxxxxxx ，其中xxxxxxx表示小数部分，因为IEEE 754规定，在计算机中保存M时，默认这个数的第一位总是1，因此可以舍去，只保存后面xxxxxxx的部分，等到读取的时候，再把第一位的1加上去，这样做可以节省一位有效数字， 增加一位精度。<br>
<img src="https://zht88821.github.io/post-images/1621922029483.png" alt="" loading="lazy"></p>
<p>指数E的情况比较复杂，E为一个无符号整数（unsigned int)，如果E为8位，它的取值范围为0-255，但是我们知道科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须加上一个中间数， 对于8位的E，这个中间数是127，比如E = 10时，存入内存就要保存成10+127=137，即10001001。<br>
<img src="https://zht88821.github.io/post-images/1621922422654.png" alt="" loading="lazy"><br>
E从内存中取出来也有三种情况：<br>
<img src="https://zht88821.github.io/post-images/1621922585734.png" alt="" loading="lazy"><br>
那么上述用浮点数打印整数和用整数打印浮点数的异常就可以解释了：<br>
<img src="https://zht88821.github.io/post-images/1621922893272.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1621923107781.png" alt="" loading="lazy"></p>
<p>数据的存储就讲到这，希望对大家有帮助！😄</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之初识指针]]></title>
        <id>https://zht88821.github.io/post/c-yu-yan-zhi-chu-shi-zhi-zhen/</id>
        <link href="https://zht88821.github.io/post/c-yu-yan-zhi-chu-shi-zhi-zhen/">
        </link>
        <updated>2021-05-18T13:23:00.000Z</updated>
        <content type="html"><![CDATA[<p>今天学了一点C语言中指针的知识，现在来总结一下。</p>
<p>指针是什么？通俗点来讲，指针就是一个变量，是用来存放地址的变量。地址是用来唯一标识一块空间的，指针变量的大小在32位机器上是4字节，在64位机器上是8个字节。那么指针有哪些类型呢？我们知道在C语言中有int类型，char类型，short类型，float类型等等，而指针的类型的定义方式为type*  ，比如int* 、char* 、short* 、float* 等等，不同的类型存放的地址不同，比如：int* 类型是为了存放int类型变量的地址，char* 类型是为了存放char类型变量的地址。</p>
<p>我们来谈一下指针类型的意义是什么？<br>
①.指针+-整数<br>
<img src="https://zht88821.github.io/post-images/1621344819787.png" alt="" loading="lazy"><br>
指针类型决定指针向前或向后走一步的距离。比如说（char*+1）指向下一个字节，而(int*+1)指向后面第4个字节。<br>
②.指针的解引用（如下图描述）<br>
<img src="https://zht88821.github.io/post-images/1621345090423.png" alt="" loading="lazy"></p>
<p>指针还会出现一种情况，那就是野指针：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）。出现野指针会使程序出错，那么哪些情况会出现野指针呢？<br>
①指针未初始化<br>
<img src="https://zht88821.github.io/post-images/1621345308945.png" alt="" loading="lazy"><br>
②指针越界访问<br>
<img src="https://zht88821.github.io/post-images/1621345349692.png" alt="" loading="lazy"><br>
③指针指向的空间释放<br>
比如说函数中的局部变量的地址赋给了一个指针，但是出了函数局部变量销毁，就会引起这种情况。<br>
那么如何规避野指针呢？有四种方法：①.指针初始化  。   ②.小心指针越界。  ③. 指针指向空间释放的变量即置为NULL。   ④. 指针使用之前检查有效性。<br>
<img src="https://zht88821.github.io/post-images/1621345590405.png" alt="" loading="lazy"></p>
<p>指针的运算有三种方式：①指针+-整数<br>
<img src="https://zht88821.github.io/post-images/1621345760640.png" alt="" loading="lazy"><br>
在数组中运用指针+-整数可以找到不同的元素。<br>
②指针-指针<br>
<img src="https://zht88821.github.io/post-images/1621345869418.png" alt="" loading="lazy"><br>
在求数组中元素个数可以运用这个运算。<br>
③指针的关系运算<br>
<img src="https://zht88821.github.io/post-images/1621345997305.png" alt="" loading="lazy"><br>
但是上述代码不可以写成这样：<br>
<img src="https://zht88821.github.io/post-images/1621346160559.png" alt="" loading="lazy"><br>
这样指针会越界成为野指针，还有C语言标准规定允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。</p>
<p>在数组中，可以使用指针来访问数组：<br>
<img src="https://zht88821.github.io/post-images/1621346573989.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1621346580567.png" alt="" loading="lazy"></p>
<p>指针中还有二级指针。<br>
<img src="https://zht88821.github.io/post-images/1621346732610.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1621346739947.png" alt="" loading="lazy"></p>
<p>指针也可以有数组，称为指针数组，数组里的元素就是指针类型变量。<br>
<img src="https://zht88821.github.io/post-images/1621346827484.png" alt="" loading="lazy"></p>
<p>总结了下简单的指针内容，希望对大家有帮助😄。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之操作符]]></title>
        <id>https://zht88821.github.io/post/c-yu-yan-zhi-cao-zuo-fu/</id>
        <link href="https://zht88821.github.io/post/c-yu-yan-zhi-cao-zuo-fu/">
        </link>
        <updated>2021-05-17T13:30:46.000Z</updated>
        <content type="html"><![CDATA[<p>操作符是C语言中计算求值的工具，类似于数学中的加减乘除等各种符号，操作符分成：算术操作符、移位操作符、位操作符、赋值操作符、单目操作符、关系操作符、逻辑操作符、条件操作符、逗号操作符、下标引用操作符、函数调用操作符、结构成员操作符等，操作符的使用也有严格的规定，现在我来随便谈谈关于操作符。<br>
一、算数操作符。算数操作符有+、-、*、/、%，使用有一定的规则：1.除了% 操作符，其他操作符可以作用于整型和浮点型。     2.对于/操作符，如果两个操作数为整型，则执行整型除法，返回商；而只要有浮点型，则执行浮点型除法。    3.%操作符的两个操作数必须为整型，返回的是整除后的余数。</p>
<p>二、移位操作符。移位操作符移动的是二进制位，有&lt;&lt;（左移操作符）、&gt;&gt;(右移操作符)。  左移操作符的规则：左边抛弃，右边补零。<br>
<img src="https://zht88821.github.io/post-images/1621259026675.png" alt="" loading="lazy"><br>
右移操作符的规则分为两种：1.逻辑右移，左边用0填充，右边抛弃；2.算数右移，左边用原数符号位填充，右边抛弃。<br>
<img src="https://zht88821.github.io/post-images/1621259213659.png" alt="" loading="lazy"><br>
对于移位操作符，不能移动负数位。<br>
nt num = 10;<br>
num&gt;&gt;-1;//error</p>
<p>三、位操作符。位操作符有&amp;(按位与)、|(按位或)、^(按位异或)，位操作符操作数必须为整数。<br>
位操作符的简单代码应用：<br>
<img src="https://zht88821.github.io/post-images/1621259502845.png" alt="" loading="lazy"></p>
<p>四、赋值操作符。=为赋值操作符，可以给变量赋上你想要的值。又有复合赋值操作符，+=、-=、*=、 /=、%=、》=、《=、&amp;=、|=、^=。比如 a = a+2等价于a += 2。</p>
<p>五、单目操作符。单目操作符有!(逻辑反操作)、-(负值)、+(正值)、&amp;(取地址)、sizeof(操作数的类型长度)、~(按二进制位取反)、++、--、*(解引用操作符)、(类型)强制类型转换。</p>
<p>六、关系操作符。&gt;、&gt;=、&lt;、&lt;=、!=、==。</p>
<p>七、逻辑操作符。逻辑&amp;&amp;、逻辑||。注意！！：逻辑&amp;&amp;只要左边为假，就不计算右边的表达式；逻辑||只要左边为真，就不计算右边的表达式。</p>
<p>八、条件操作符。exp1 ? exp2 : exp3。意思是式子1为真，结果为式子2，否则为式子3。</p>
<p>九、逗号表达式。逗号表达式是用逗号隔开的多个表达式。执行顺序为从左向右依次执行。整个表达式的结果是最后一个表达式的结果。</p>
<p>十、下标引用、函数调用、结构成员。下标引用[]的操作数为：一个数组名+一个索引值。<br>
( ) 函数调用操作符 接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。<br>
访问一个结构体的成员有.操作符和-&gt;操作符。使用方法如图：<br>
<img src="https://zht88821.github.io/post-images/1621260889642.png" alt="" loading="lazy"></p>
<p>有些表达式的操作数在运算时可能需要类型转换，有两种隐式类型转换：第一种为整形提升，用于计算长度小于int或unsigned int的类型，先转换为后者，再进行运算。整形提升的规则为：1.有符号位按照高位补充符号位。2.无符号位高位补充0。实例如下：<br>
<img src="https://zht88821.github.io/post-images/1621261281046.png" alt="" loading="lazy"><br>
整形提升的代码例子：<br>
<img src="https://zht88821.github.io/post-images/1621261408942.png" alt="" loading="lazy"><br>
执行结果为只打印c。<br>
第二种隐式转换为算数转换：较低精度的操作数转换为较高精度的操作数类型，注意可能会丢失精度。</p>
<p>操作符讲完了，现在来讲讲操作符的属性。操作符的属性有三部分：1.操作符的优先级。2.操作符的结合性<br>
3.是否控制求值顺序。两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。有是否控制求值性质的操作符有 ?     :  、&amp;&amp;、||、逗号 。  因为能控制求值，比如说逻辑与左边为假，那就直接为假，不再计算右边表达式的值。</p>
<p>在进行表达式求值的时候，会出现表达式有许多条路径解法，比如：<br>
<img src="https://zht88821.github.io/post-images/1621261972605.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1621262025906.png" alt="" loading="lazy"><br>
所以得出结论：我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题的。</p>
<p>关于操作符讲完了，如果能帮到大家，我感到十分荣幸！😁</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于扫雷游戏的C语言代码实现与心得]]></title>
        <id>https://zht88821.github.io/post/guan-yu-sao-lei-you-xi-de-c-yu-yan-dai-ma-shi-xian-yu-xin-de/</id>
        <link href="https://zht88821.github.io/post/guan-yu-sao-lei-you-xi-de-c-yu-yan-dai-ma-shi-xian-yu-xin-de/">
        </link>
        <updated>2021-05-14T07:43:51.000Z</updated>
        <content type="html"><![CDATA[<p>扫雷相信大家都玩过吧，就是一个矩形方阵中有一些雷，你点到不是雷的位置，会显示周围一圈有几个雷，直到把所有非雷方格都点完，就算是游戏胜利了。<br>
在C语言中实现这个逻辑要怎么考虑呢？同样我们用到了数组，这次我们用两个数组来实现，一个用来存放雷的数组，一个用来存放显示给玩家棋盘游戏状态的数组，有了两个数组，我们要先初始化，打印棋盘，然后布置雷，扫雷，每一步判断一下是否胜利，进阶一下，我们可以设计一个函数实现：如果一个坐标不是雷，让周围不是雷的一大片一起消除，直到周围有雷为止；还可以设计做标记、第一步就踩雷的话重置雷等等。整体的逻辑就是这样，我们来实现一下。<br>
首先依然在VS编译器中创建一个扫雷游戏的项目，在项目里面创建text.c、game.c和game.h三个文件，分别用来存放游戏main函数及游戏流程、函数的实现、函数的声明。<br>
<img src="https://zht88821.github.io/post-images/1620978949791.png" alt="" loading="lazy"><br>
创建好后，我们首先要实现流程和main（）函数，main()函数就很简单的流程：<br>
<img src="https://zht88821.github.io/post-images/1620979211381.png" alt="" loading="lazy"><br>
main函数中的test()函数：<br>
<img src="https://zht88821.github.io/post-images/1620979318165.png" alt="" loading="lazy"><br>
函数中实现了游戏的流程，其中的srand是用来设置时间戳，为之后的随机取值做准备，menu（）函数的实现很简单：<br>
<img src="https://zht88821.github.io/post-images/1620979533001.png" alt="" loading="lazy"><br>
选择1进入游戏后，game函数是游戏的总流程，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620979618804.png" alt="" loading="lazy"><br>
其中的流程是，先创建数组，一个用来布置雷，一个用来排查雷，然后再用自定义的InitBoard（）函数用来初始化数组，SetMine（）用来布置雷，DisplayBoard()用来打印棋盘，最后FindMine() 用来扫雷和判断游戏状态。知道了大概流程，我们在game.h头文件中声明一下我们需要的这些函数：<br>
<img src="https://zht88821.github.io/post-images/1620979856624.png" alt="" loading="lazy"><br>
函数的意义图片上一一都注释出来了，引了三个头文件需要用，定义了五个常量后面都要用，这样定义常量，方便游戏后面修改棋盘的大小和雷的数量。到现在为止，game.h头文件和test.c测试文件都已经编辑好了，我们最后来编辑game.c文件，来实现声明的这些函数。<br>
InitBoard()初始化棋盘函数的实现：<br>
<img src="https://zht88821.github.io/post-images/1620980095024.png" alt="" loading="lazy"><br>
形参set用来指示初始化的字符，方便两个棋盘不同的初始化要求。<br>
DisplayBoard()打印棋盘函数的实现:<br>
<img src="https://zht88821.github.io/post-images/1620980214900.png" alt="" loading="lazy"><br>
SetMine（）布置雷函数的实现：<br>
<img src="https://zht88821.github.io/post-images/1620980411730.png" alt="" loading="lazy"><br>
定义的常量EASY_COUNT用来指定雷的数量，这时候rand()函数用来随机在棋盘中放置雷，rand() % row + 1 和 rand() % col + 1刚好在1-9范围内，符合我们要随机布置雷的要求。<br>
FindMine()排雷的函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620980919600.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620980926286.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620980931230.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620980936151.png" alt="" loading="lazy"><br>
排雷函数有点长，首先我们在一个大while循环中，用switch函数让我们选择，这里我设计了三个选项：1.排雷；2.做标记；3.取消标记；分别对应case1、case2、case3。   排雷中如果第一步就踩雷我们就重置雷，用rand()随机让一个不为雷的位置变成雷，而第一步踩到的雷变成了非雷，然后继续游戏，整形变量cnt用来存放非雷的数量，用来后面判断是否胜利,get_mine_count（)用来统计坐标周围雷的数量，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620982014989.png" alt="" loading="lazy"><br>
函数类型为int型，最后还要加一个'0'变成整形，原理去看ASCII码表🤣<br>
Clean（）函数用来一次性排除非雷位置周围所有非雷位置，直到展开到周围有雷为止，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620982575311.png" alt="" loading="lazy"><br>
函数的大概意思就是先判断非雷坐标周围八个坐标的周围八个坐标周围是否有雷，直到旁边有雷就停止，没有雷继续递归调用Clean()函数，实现一次展开大量非雷坐标，用count接收展开的格子数，后面cnt-count用来判断是否胜利。<br>
标记功能和取消标记功能的实现很简单，就不赘述了，还用了一个goto语句如果不是第一次踩雷，就跳转到end语句进行判断，整个游戏的实现就讲的差不多了。</p>
<p>运行结果：<br>
排雷：<br>
<img src="https://zht88821.github.io/post-images/1620983232606.png" alt="" loading="lazy"><br>
标记：<br>
<img src="https://zht88821.github.io/post-images/1620983252172.png" alt="" loading="lazy"><br>
取消标记：<br>
<img src="https://zht88821.github.io/post-images/1620983267291.png" alt="" loading="lazy"><br>
扫雷成功：<br>
<img src="https://zht88821.github.io/post-images/1620983471137.png" alt="" loading="lazy"><br>
被炸死了：<br>
<img src="https://zht88821.github.io/post-images/1620983521050.png" alt="" loading="lazy"><br>
我的心得讲完了，希望能帮助到大家！😄，具体的代码在我的github上：https://github.com/zht88821/C_CODE。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于三子棋游戏的C语言实现]]></title>
        <id>https://zht88821.github.io/post/guan-yu-san-zi-qi-you-xi-de-c-yu-yan-shi-xian/</id>
        <link href="https://zht88821.github.io/post/guan-yu-san-zi-qi-you-xi-de-c-yu-yan-shi-xian/">
        </link>
        <updated>2021-05-13T12:58:03.000Z</updated>
        <content type="html"><![CDATA[<p>最近学到了三子棋游戏的C语言实现，在这里我写一写我自己的心得吧！😄<br>
什么是三子棋呢，简单来说，就是上学时候经常在本子上画来画去的井字棋，<br>
只要横着、竖着或者斜着三个相同的子连成一条线，就算游戏胜利，两个玩家参与，采用回合制。规则是不是很简单呢？现在我们来谈一下，如果要在C语言中实现，要考虑哪些问题呢，首先要考虑的是棋盘上下棋的信息怎么保存，刚学过数组，我们就用3*3的二维数组来保存我们棋子的信息，棋盘的打印就封装一个函数来实现，棋盘在没下之前要‘清空’，所以我们还得封装一个初始化二维数组的函数， 下棋的时候就下在二维数组的对应位置，玩家下棋得封装一个函数，电脑下棋的函数要实现随机，每下完一步还得判断下是否有输赢，或者平局。大致的思路就是这样，现在我们来开始实现代码。<br>
我们首先先在vs编译器上创建一个项目，创建一个test.c源文件，用作测试；一个game.c源文件，用于代码的具体实现；一个game.h头文件，用于函数的声明。大概是这样：<br>
<img src="https://zht88821.github.io/post-images/1620911963182.png" alt="" loading="lazy"><br>
我们要写test.c文件，把整个程序的执行流程写下来：<br>
<img src="https://zht88821.github.io/post-images/1620912080449.png" alt="" loading="lazy"><br>
封装了一个test（）函数，test()函数的实现为：<br>
<img src="https://zht88821.github.io/post-images/1620912148392.png" alt="" loading="lazy"><br>
先进入游戏，先打印菜单，封装一个菜单函数：<br>
<img src="https://zht88821.github.io/post-images/1620912332321.png" alt="" loading="lazy"><br>
接下来就进入游戏流程了，输入1，进入游戏：<br>
<img src="https://zht88821.github.io/post-images/1620912601654.png" alt="" loading="lazy"><br>
游戏的流程在图片中说明了，其中封装的函数在game.h头文件中也声明了<br>
<img src="https://zht88821.github.io/post-images/1620913024438.png" alt="" loading="lazy"><br>
函数的大概意思也注释了，还定义两个常量ROW、COL，方便棋盘大小的更改，引入三个头文件会在后面用到。InitBoard()函数的实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620913254665.png" alt="" loading="lazy"><br>
DisplayBoard()函数的实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620913323916.png" alt="" loading="lazy"><br>
井字棋的打印的要点是分组将数据行和分割行循环打印大概这样分组：<br>
<img src="https://zht88821.github.io/post-images/1620914323338.png" alt="" loading="lazy"><br>
就这样打印一行数据，打印一行分割行，再设置条件每行数据和分割行的最后一个竖杠不用打印，而且分割行只需打印row-1行。数据行相当于:   |   |   |,最后一个|不用打；分割行相当于:---|---|---|,同理最后一个|不用打，这样就好设置条件完成棋盘的打印了。<br>
PlayerMove函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620973958678.png" alt="" loading="lazy"><br>
大致就是判断输入的坐标是否合法，合法的话就存在数组里。<br>
ComputerMove函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620974287867.png" alt="" loading="lazy"><br>
用rand()函数实现电脑随机走棋。<br>
每次玩家或者电脑走完棋之后还要判断下游戏的状态，封装了IsWin函数，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620974610165.png" alt="" loading="lazy"><br>
判断横三行，竖三行和两个对角线是否相等且不为空，如果没有就判断棋盘是否满了，封装了一个IsFull函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620974949634.png" alt="" loading="lazy"><br>
如果都不满足，则继续游戏。<br>
游戏运行结果如下：<br>
玩家赢的情况：<br>
<img src="https://zht88821.github.io/post-images/1620976259624.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620976267423.png" alt="" loading="lazy"><br>
电脑赢的情况：<br>
<img src="https://zht88821.github.io/post-images/1620976495695.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620976503782.png" alt="" loading="lazy"><br>
平局的情况:<br>
<img src="https://zht88821.github.io/post-images/1620976820759.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620976833394.png" alt="" loading="lazy"></p>
<p>这个游戏的讲解到这里了，具体的代码实现到我的github上有：https://github.com/zht88821/C_CODE，希望能帮到大家！😀</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言-数组-冒泡排序及数组传参的用法]]></title>
        <id>https://zht88821.github.io/post/c-yu-yan-shu-zu-mou-pao-pai-xu-ji-shu-zu-chuan-can-de-yong-fa/</id>
        <link href="https://zht88821.github.io/post/c-yu-yan-shu-zu-mou-pao-pai-xu-ji-shu-zu-chuan-can-de-yong-fa/">
        </link>
        <updated>2021-05-10T09:03:41.000Z</updated>
        <content type="html"><![CDATA[<p>在学习了数组的有关知识后，和B站教学视频一起码了个冒泡排序，啥是冒泡排序呢？很简单，就是将一个数组按照升/降序排列，很简单的一个小问题，直接上代码：<br>
<img src="https://zht88821.github.io/post-images/1620638475146.png" alt="" loading="lazy"><br>
在代码里定义了一个bubble_sort函数，这里是用来将数组按升序排序的，数组的个数sz的计算之所以不能在函数中，是因为数组名传参只是传过去首元素的地址，在函数中使用sizeof运算符不能计算出正确的数组个数，所以在   main函数中提前将sz算出，然后作为函数参数输入，这里继续提一句，一般来说数组名传参代表首元素的地址，但有两种特殊情况：①在sizeof(数组名)的时候，数组名代表整个数组；②&amp;数组名 代表的是整个数组的地址。<br>
函数中设置了flag，防止在数组已经有序的情况下，进行多余的运算。<br>
此代码的运行结果：<br>
<img src="https://zht88821.github.io/post-images/1620638127505.png" alt="" loading="lazy"><br>
冒泡排序啰嗦到这了，希望能帮到大家！😁</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[小青蛙跳台阶问题的心得]]></title>
        <id>https://zht88821.github.io/post/xiao-qing-wa-tiao-tai-jie-wen-ti-de-xin-de/</id>
        <link href="https://zht88821.github.io/post/xiao-qing-wa-tiao-tai-jie-wen-ti-de-xin-de/">
        </link>
        <updated>2021-05-08T13:50:57.000Z</updated>
        <content type="html"><![CDATA[<p>今天简单研究了下小青蛙问题，类似于斐波那契数列，废话不多说，现在来总结一下这个问题！<br>
我把小青蛙问题分成成两个模块，一个是简单版，一个是进阶版，我们先来讲讲简单版本的小青蛙问题：有一只小青蛙一次能跳1个台阶或者2个台阶，如果台阶一共有n个，问小青蛙总共有多少种跳法？ 先从最简单的问题入手，如果n=1的时候，，小青蛙一共只能选择（1）这1种跳法，如果n=2的时候，小青蛙可以选择（1,1）或者（2）这2种跳法，那么n=3的时候，小青蛙可以选择（1,1,1）、（1,2）、（2,1）3种跳法，n=4的时候可以选择（1,1,1,1)、（1,1,2)、(1,2,1)、(2,2)、(2,1,1)五种，为了方便理解，我们把小青蛙问题看成一个函数：f(n)=n级台阶小青蛙能够选择的跳法总数，根据前面简单列举的几种情况，能发现一点简单的规律，比如：f(3)=f(2)+f(1)、f(4)=f(3)+f(2)。但是研究问题是要严谨的，不能这么随意的就下结论，我们来继续研究一下，当n很大的时候，最后一步无非就只有两种情况：最后一步还剩下1个台阶或者最后一步还剩下2个台阶。  把问题想到这里，就感觉豁然开朗了，最后一步剩下1个台阶的方法数就是f(n-1)，最后一步剩下2个台阶的方法数就是f(n-2),那么就得出我们的推论：      f(n)=f(n-1)+f(n-2),事实上的定论和我们的推论是一样的，在知道了原理，现在我们可以来开始用C语言实现这个问题啦！<br>
<img src="https://zht88821.github.io/post-images/1620482199987.png" alt="" loading="lazy"><br>
在图中jump1函数是用函数递归的方式实现这个问题的，已知最简单的n=1和n=2的时候直接返回种类，将n =1和 n=2设置为递归的出口，在n&gt;2的时候用了公式f(n)=f(n-1)+f(n-2),实现了这个游戏，但是用函数递归的方法可以发现，f(n)=f(n-1)+f(n-2) , 其中的f(n-1)递归成f(n-2)+f(n-3), 其中的f(n-2)又递归成f(n-3)+f(n-4)，可以发现计算中需要大量重复计算相同的值，计算存在大量的冗余，当n的值非常大时 ，计算的效率很低很低，那有什么办法解决呢？<br>
解决办法就是图中的jump2函数，用循环方式解决了计算的大量冗余，使计算不存在冗余，大大提高计算速度。for循环中运用了三个整形变量a,b,c，当n = 1时直接输出1种，当n&gt;=2时，使a+b的值赋给c，b赋给a,c赋给b，循环往复，实现了数值的变化，跳出for循环后在最后返回c。当n=6的时候程序的运行结果如下：<br>
<img src="https://zht88821.github.io/post-images/1620482341731.png" alt="" loading="lazy"><br>
此时小青蛙问题的简易版就解决啦，接下来可以挑战进阶版了😀<br>
那么什么是小青蛙问题的进阶版呢？就是把问题稍微改一下，假设有n个台阶，小青蛙现在可以一次跳1个台阶、一次跳2个台阶、一次跳3个台阶...一次跳n个台阶，请问小青蛙共有多少种跳法呢？是不是感觉难一点了呢，把这个问题弄懂，小青蛙问题应该就没问题了吧，现在我们来讨论一下这个问题？<br>
如果是这样，那么一共有多少种跳法呢？其实思路和简单版的一样，我们可以在最后一步剩余不同的台阶个数，在跳到最后一步只剩余一格的时候，最后一步留有一格的情况下有f(n-1)种，类似的在最后一步只剩余两格的时候有f(n-2种，以此类推，所以f(n)=f(n-1)+f(n-2)+....+f(1)+1,加1是因为可以直接一步跳完，我们又可以发现f(n-1)=f(n-2)+f(n-3)+...+f(1)+1, 所以f(n) = 2*f(n-1)，在理清了思路后我们就可以用C语言来实现啦！下面是C语言实现：<br>
<img src="https://zht88821.github.io/post-images/1620483876997.png" alt="" loading="lazy"><br>
函数jump_adv就是解决进阶版问题的函数了，这里直接用循环方式了，不写递归方式了，因为循环方式比递归方式更优，函数里设置了整形变量sum和a，sum用来计算公式f(n)=f(n-1)+f(n-2)+...+f(1)+1的累加和，a是初始值，sum将即将改变的值赋给a和sum每次加上新的a的值实现函数，详细的解析写在图片里了。当n=6时，程序执行的结果如下：<br>
<img src="https://zht88821.github.io/post-images/1620484153734.png" alt="" loading="lazy"><br>
到现在为止，小青蛙跳台阶的问题算是讲清楚了，如果能帮到你，那是我的荣幸，很高兴分享自己的心得😋！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汉诺塔游戏的心得]]></title>
        <id>https://zht88821.github.io/post/han-nuo-ta-you-xi-de-xin-de/</id>
        <link href="https://zht88821.github.io/post/han-nuo-ta-you-xi-de-xin-de/">
        </link>
        <updated>2021-05-07T13:52:04.000Z</updated>
        <content type="html"><![CDATA[<p>从昨天到现在的碎片时间研究了下汉诺塔游戏的c语言实现，看到鹏哥c语言中提到了这个，就来试着自己学一学，刚学到递归调用，汉诺塔也算是一个递归调用的经典例题，刚好来巩固一下所学的知识，一开始谷歌了下网上的文档，内容不怎么容易懂，没怎么搞清楚，然后在B站找了个视频看，现在终于弄得差不多懂了，来分享一下自己的想法。<br>
先来简单介绍一下汉诺塔游戏，我直接谷歌了一下简介：汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。简单来说就是有三根柱子A、B、C,在A上有若干个从下往上逐渐变小的圆盘，要从柱子A借助柱子B转移到柱子C，规则就是：①一次只能转移一个圆盘。②较大的圆盘不能放在较小的圆盘上。<img src="https://zht88821.github.io/post-images/1620396589941.jfif" alt="" loading="lazy">  如果只是让你直接操作应该也不算难，如果在c语言上实现呢?<br>
这个游戏算法在c语言中实现需要用到函数递归，要用到递归，那么首先需要把一个大的问题分解成一个小的步骤，然后能重复调用这个步骤接近结果，直到执行结束。<img src="https://zht88821.github.io/post-images/1620396955102.png" alt="" loading="lazy">分解步骤我在B站看的视频里已经写的很明白了，我就直接借用这张图来描述了。图中把整个过程分成了三步，其中第一步和第三步又可以各自看成一次汉诺塔游戏，递归调用重复这三个步骤，递归的出口就是只剩下一个盘子的时候把最后一个盘子移到目的杆子上。<br>
借助这个思想，就可以在编译器上来实现<img src="https://zht88821.github.io/post-images/1620397429887.png" alt="" loading="lazy"><br>
假设有3个盘子的时候，程序的执行结果：<img src="https://zht88821.github.io/post-images/1620397541028.png" alt="" loading="lazy"><br>
汉诺塔游戏的心得到这里了，如果能帮到大家，是我的荣幸😀！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World!!!]]></title>
        <id>https://zht88821.github.io/post/hello-world/</id>
        <link href="https://zht88821.github.io/post/hello-world/">
        </link>
        <updated>2021-04-29T10:07:24.000Z</updated>
        <content type="html"><![CDATA[<p>忙活了几天终于把属于自己的博客创建起来了😋，也是我第一次写博客，作为未来的IT新星，我会在这里分享我学习的经验，希望能和大家一起交流学习，能一起进步！😀 顺便记录下自己成长的历程和阶段，希望成为一个非常厉害的程序员，希望能赚大钱，加油！ 千里之行始于足下，每天的积累至关重要，坚持学习将是我最厉害的武器！</p>
]]></content>
    </entry>
</feed>
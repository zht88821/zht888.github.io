<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zht88821.github.io</id>
    <title>zht的技术小站</title>
    <updated>2021-05-18T14:17:48.207Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zht88821.github.io"/>
    <link rel="self" href="https://zht88821.github.io/atom.xml"/>
    <subtitle>加油学习赚大钱！！！
</subtitle>
    <logo>https://zht88821.github.io/images/avatar.png</logo>
    <icon>https://zht88821.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, zht的技术小站</rights>
    <entry>
        <title type="html"><![CDATA[C语言之初识指针]]></title>
        <id>https://zht88821.github.io/post/c-yu-yan-zhi-chu-shi-zhi-zhen/</id>
        <link href="https://zht88821.github.io/post/c-yu-yan-zhi-chu-shi-zhi-zhen/">
        </link>
        <updated>2021-05-18T13:23:00.000Z</updated>
        <content type="html"><![CDATA[<p>今天学了一点C语言中指针的知识，现在来总结一下。</p>
<p>指针是什么？通俗点来讲，指针就是一个变量，是用来存放地址的变量。地址是用来唯一标识一块空间的，指针变量的大小在32位机器上是4字节，在64位机器上是8个字节。那么指针有哪些类型呢？我们知道在C语言中有int类型，char类型，short类型，float类型等等，而指针的类型的定义方式为type*  ，比如int* 、char* 、short* 、float* 等等，不同的类型存放的地址不同，比如：int* 类型是为了存放int类型变量的地址，char* 类型是为了存放char类型变量的地址。</p>
<p>我们来谈一下指针类型的意义是什么？<br>
①.指针+-整数<br>
<img src="https://zht88821.github.io/post-images/1621344819787.png" alt="" loading="lazy"><br>
指针类型决定指针向前或向后走一步的距离。比如说（char*+1）指向下一个字节，而(int*+1)指向后面第4个字节。<br>
②.指针的解引用（如下图描述）<br>
<img src="https://zht88821.github.io/post-images/1621345090423.png" alt="" loading="lazy"></p>
<p>指针还会出现一种情况，那就是野指针：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）。出现野指针会使程序出错，那么哪些情况会出现野指针呢？<br>
①指针未初始化<br>
<img src="https://zht88821.github.io/post-images/1621345308945.png" alt="" loading="lazy"><br>
②指针越界访问<br>
<img src="https://zht88821.github.io/post-images/1621345349692.png" alt="" loading="lazy"><br>
③指针指向的空间释放<br>
比如说函数中的局部变量的地址赋给了一个指针，但是出了函数局部变量销毁，就会引起这种情况。<br>
那么如何规避野指针呢？有四种方法：①.指针初始化  。   ②.小心指针越界。  ③. 指针指向空间释放的变量即置为NULL。   ④. 指针使用之前检查有效性。<br>
<img src="https://zht88821.github.io/post-images/1621345590405.png" alt="" loading="lazy"></p>
<p>指针的运算有三种方式：①指针+-整数<br>
<img src="https://zht88821.github.io/post-images/1621345760640.png" alt="" loading="lazy"><br>
在数组中运用指针+-整数可以找到不同的元素。<br>
②指针-指针<br>
<img src="https://zht88821.github.io/post-images/1621345869418.png" alt="" loading="lazy"><br>
在求数组中元素个数可以运用这个运算。<br>
③指针的关系运算<br>
<img src="https://zht88821.github.io/post-images/1621345997305.png" alt="" loading="lazy"><br>
但是上述代码不可以写成这样：<br>
<img src="https://zht88821.github.io/post-images/1621346160559.png" alt="" loading="lazy"><br>
这样指针会越界成为野指针，还有C语言标准规定允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。</p>
<p>在数组中，可以使用指针来访问数组：<br>
<img src="https://zht88821.github.io/post-images/1621346573989.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1621346580567.png" alt="" loading="lazy"></p>
<p>指针中还有二级指针。<br>
<img src="https://zht88821.github.io/post-images/1621346732610.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1621346739947.png" alt="" loading="lazy"></p>
<p>指针也可以有数组，称为指针数组，数组里的元素就是指针类型变量。<br>
<img src="https://zht88821.github.io/post-images/1621346827484.png" alt="" loading="lazy"></p>
<p>总结了下简单的指针内容，希望对大家有帮助😄。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言之操作符]]></title>
        <id>https://zht88821.github.io/post/c-yu-yan-zhi-cao-zuo-fu/</id>
        <link href="https://zht88821.github.io/post/c-yu-yan-zhi-cao-zuo-fu/">
        </link>
        <updated>2021-05-17T13:30:46.000Z</updated>
        <content type="html"><![CDATA[<p>操作符是C语言中计算求值的工具，类似于数学中的加减乘除等各种符号，操作符分成：算术操作符、移位操作符、位操作符、赋值操作符、单目操作符、关系操作符、逻辑操作符、条件操作符、逗号操作符、下标引用操作符、函数调用操作符、结构成员操作符等，操作符的使用也有严格的规定，现在我来随便谈谈关于操作符。<br>
一、算数操作符。算数操作符有+、-、*、/、%，使用有一定的规则：1.除了% 操作符，其他操作符可以作用于整型和浮点型。     2.对于/操作符，如果两个操作数为整型，则执行整型除法，返回商；而只要有浮点型，则执行浮点型除法。    3.%操作符的两个操作数必须为整型，返回的是整除后的余数。</p>
<p>二、移位操作符。移位操作符移动的是二进制位，有&lt;&lt;（左移操作符）、&gt;&gt;(右移操作符)。  左移操作符的规则：左边抛弃，右边补零。<br>
<img src="https://zht88821.github.io/post-images/1621259026675.png" alt="" loading="lazy"><br>
右移操作符的规则分为两种：1.逻辑右移，左边用0填充，右边抛弃；2.算数右移，左边用原数符号位填充，右边抛弃。<br>
<img src="https://zht88821.github.io/post-images/1621259213659.png" alt="" loading="lazy"><br>
对于移位操作符，不能移动负数位。<br>
nt num = 10;<br>
num&gt;&gt;-1;//error</p>
<p>三、位操作符。位操作符有&amp;(按位与)、|(按位或)、^(按位异或)，位操作符操作数必须为整数。<br>
位操作符的简单代码应用：<br>
<img src="https://zht88821.github.io/post-images/1621259502845.png" alt="" loading="lazy"></p>
<p>四、赋值操作符。=为赋值操作符，可以给变量赋上你想要的值。又有复合赋值操作符，+=、-=、*=、 /=、%=、》=、《=、&amp;=、|=、^=。比如 a = a+2等价于a += 2。</p>
<p>五、单目操作符。单目操作符有!(逻辑反操作)、-(负值)、+(正值)、&amp;(取地址)、sizeof(操作数的类型长度)、~(按二进制位取反)、++、--、*(解引用操作符)、(类型)强制类型转换。</p>
<p>六、关系操作符。&gt;、&gt;=、&lt;、&lt;=、!=、==。</p>
<p>七、逻辑操作符。逻辑&amp;&amp;、逻辑||。注意！！：逻辑&amp;&amp;只要左边为假，就不计算右边的表达式；逻辑||只要左边为真，就不计算右边的表达式。</p>
<p>八、条件操作符。exp1 ? exp2 : exp3。意思是式子1为真，结果为式子2，否则为式子3。</p>
<p>九、逗号表达式。逗号表达式是用逗号隔开的多个表达式。执行顺序为从左向右依次执行。整个表达式的结果是最后一个表达式的结果。</p>
<p>十、下标引用、函数调用、结构成员。下标引用[]的操作数为：一个数组名+一个索引值。<br>
( ) 函数调用操作符 接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。<br>
访问一个结构体的成员有.操作符和-&gt;操作符。使用方法如图：<br>
<img src="https://zht88821.github.io/post-images/1621260889642.png" alt="" loading="lazy"></p>
<p>有些表达式的操作数在运算时可能需要类型转换，有两种隐式类型转换：第一种为整形提升，用于计算长度小于int或unsigned int的类型，先转换为后者，再进行运算。整形提升的规则为：1.有符号位按照高位补充符号位。2.无符号位高位补充0。实例如下：<br>
<img src="https://zht88821.github.io/post-images/1621261281046.png" alt="" loading="lazy"><br>
整形提升的代码例子：<br>
<img src="https://zht88821.github.io/post-images/1621261408942.png" alt="" loading="lazy"><br>
执行结果为只打印c。<br>
第二种隐式转换为算数转换：较低精度的操作数转换为较高精度的操作数类型，注意可能会丢失精度。</p>
<p>操作符讲完了，现在来讲讲操作符的属性。操作符的属性有三部分：1.操作符的优先级。2.操作符的结合性<br>
3.是否控制求值顺序。两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。有是否控制求值性质的操作符有 ?     :  、&amp;&amp;、||、逗号 。  因为能控制求值，比如说逻辑与左边为假，那就直接为假，不再计算右边表达式的值。</p>
<p>在进行表达式求值的时候，会出现表达式有许多条路径解法，比如：<br>
<img src="https://zht88821.github.io/post-images/1621261972605.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1621262025906.png" alt="" loading="lazy"><br>
所以得出结论：我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题的。</p>
<p>关于操作符讲完了，如果能帮到大家，我感到十分荣幸！😁</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于扫雷游戏的C语言代码实现与心得]]></title>
        <id>https://zht88821.github.io/post/guan-yu-sao-lei-you-xi-de-c-yu-yan-dai-ma-shi-xian-yu-xin-de/</id>
        <link href="https://zht88821.github.io/post/guan-yu-sao-lei-you-xi-de-c-yu-yan-dai-ma-shi-xian-yu-xin-de/">
        </link>
        <updated>2021-05-14T07:43:51.000Z</updated>
        <content type="html"><![CDATA[<p>扫雷相信大家都玩过吧，就是一个矩形方阵中有一些雷，你点到不是雷的位置，会显示周围一圈有几个雷，直到把所有非雷方格都点完，就算是游戏胜利了。<br>
在C语言中实现这个逻辑要怎么考虑呢？同样我们用到了数组，这次我们用两个数组来实现，一个用来存放雷的数组，一个用来存放显示给玩家棋盘游戏状态的数组，有了两个数组，我们要先初始化，打印棋盘，然后布置雷，扫雷，每一步判断一下是否胜利，进阶一下，我们可以设计一个函数实现：如果一个坐标不是雷，让周围不是雷的一大片一起消除，直到周围有雷为止；还可以设计做标记、第一步就踩雷的话重置雷等等。整体的逻辑就是这样，我们来实现一下。<br>
首先依然在VS编译器中创建一个扫雷游戏的项目，在项目里面创建text.c、game.c和game.h三个文件，分别用来存放游戏main函数及游戏流程、函数的实现、函数的声明。<br>
<img src="https://zht88821.github.io/post-images/1620978949791.png" alt="" loading="lazy"><br>
创建好后，我们首先要实现流程和main（）函数，main()函数就很简单的流程：<br>
<img src="https://zht88821.github.io/post-images/1620979211381.png" alt="" loading="lazy"><br>
main函数中的test()函数：<br>
<img src="https://zht88821.github.io/post-images/1620979318165.png" alt="" loading="lazy"><br>
函数中实现了游戏的流程，其中的srand是用来设置时间戳，为之后的随机取值做准备，menu（）函数的实现很简单：<br>
<img src="https://zht88821.github.io/post-images/1620979533001.png" alt="" loading="lazy"><br>
选择1进入游戏后，game函数是游戏的总流程，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620979618804.png" alt="" loading="lazy"><br>
其中的流程是，先创建数组，一个用来布置雷，一个用来排查雷，然后再用自定义的InitBoard（）函数用来初始化数组，SetMine（）用来布置雷，DisplayBoard()用来打印棋盘，最后FindMine() 用来扫雷和判断游戏状态。知道了大概流程，我们在game.h头文件中声明一下我们需要的这些函数：<br>
<img src="https://zht88821.github.io/post-images/1620979856624.png" alt="" loading="lazy"><br>
函数的意义图片上一一都注释出来了，引了三个头文件需要用，定义了五个常量后面都要用，这样定义常量，方便游戏后面修改棋盘的大小和雷的数量。到现在为止，game.h头文件和test.c测试文件都已经编辑好了，我们最后来编辑game.c文件，来实现声明的这些函数。<br>
InitBoard()初始化棋盘函数的实现：<br>
<img src="https://zht88821.github.io/post-images/1620980095024.png" alt="" loading="lazy"><br>
形参set用来指示初始化的字符，方便两个棋盘不同的初始化要求。<br>
DisplayBoard()打印棋盘函数的实现:<br>
<img src="https://zht88821.github.io/post-images/1620980214900.png" alt="" loading="lazy"><br>
SetMine（）布置雷函数的实现：<br>
<img src="https://zht88821.github.io/post-images/1620980411730.png" alt="" loading="lazy"><br>
定义的常量EASY_COUNT用来指定雷的数量，这时候rand()函数用来随机在棋盘中放置雷，rand() % row + 1 和 rand() % col + 1刚好在1-9范围内，符合我们要随机布置雷的要求。<br>
FindMine()排雷的函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620980919600.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620980926286.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620980931230.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620980936151.png" alt="" loading="lazy"><br>
排雷函数有点长，首先我们在一个大while循环中，用switch函数让我们选择，这里我设计了三个选项：1.排雷；2.做标记；3.取消标记；分别对应case1、case2、case3。   排雷中如果第一步就踩雷我们就重置雷，用rand()随机让一个不为雷的位置变成雷，而第一步踩到的雷变成了非雷，然后继续游戏，整形变量cnt用来存放非雷的数量，用来后面判断是否胜利,get_mine_count（)用来统计坐标周围雷的数量，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620982014989.png" alt="" loading="lazy"><br>
函数类型为int型，最后还要加一个'0'变成整形，原理去看ASCII码表🤣<br>
Clean（）函数用来一次性排除非雷位置周围所有非雷位置，直到展开到周围有雷为止，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620982575311.png" alt="" loading="lazy"><br>
函数的大概意思就是先判断非雷坐标周围八个坐标的周围八个坐标周围是否有雷，直到旁边有雷就停止，没有雷继续递归调用Clean()函数，实现一次展开大量非雷坐标，用count接收展开的格子数，后面cnt-count用来判断是否胜利。<br>
标记功能和取消标记功能的实现很简单，就不赘述了，还用了一个goto语句如果不是第一次踩雷，就跳转到end语句进行判断，整个游戏的实现就讲的差不多了。</p>
<p>运行结果：<br>
排雷：<br>
<img src="https://zht88821.github.io/post-images/1620983232606.png" alt="" loading="lazy"><br>
标记：<br>
<img src="https://zht88821.github.io/post-images/1620983252172.png" alt="" loading="lazy"><br>
取消标记：<br>
<img src="https://zht88821.github.io/post-images/1620983267291.png" alt="" loading="lazy"><br>
扫雷成功：<br>
<img src="https://zht88821.github.io/post-images/1620983471137.png" alt="" loading="lazy"><br>
被炸死了：<br>
<img src="https://zht88821.github.io/post-images/1620983521050.png" alt="" loading="lazy"><br>
我的心得讲完了，希望能帮助到大家！😄，具体的代码在我的github上：https://github.com/zht88821/C_CODE。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于三子棋游戏的C语言实现]]></title>
        <id>https://zht88821.github.io/post/guan-yu-san-zi-qi-you-xi-de-c-yu-yan-shi-xian/</id>
        <link href="https://zht88821.github.io/post/guan-yu-san-zi-qi-you-xi-de-c-yu-yan-shi-xian/">
        </link>
        <updated>2021-05-13T12:58:03.000Z</updated>
        <content type="html"><![CDATA[<p>最近学到了三子棋游戏的C语言实现，在这里我写一写我自己的心得吧！😄<br>
什么是三子棋呢，简单来说，就是上学时候经常在本子上画来画去的井字棋，<br>
只要横着、竖着或者斜着三个相同的子连成一条线，就算游戏胜利，两个玩家参与，采用回合制。规则是不是很简单呢？现在我们来谈一下，如果要在C语言中实现，要考虑哪些问题呢，首先要考虑的是棋盘上下棋的信息怎么保存，刚学过数组，我们就用3*3的二维数组来保存我们棋子的信息，棋盘的打印就封装一个函数来实现，棋盘在没下之前要‘清空’，所以我们还得封装一个初始化二维数组的函数， 下棋的时候就下在二维数组的对应位置，玩家下棋得封装一个函数，电脑下棋的函数要实现随机，每下完一步还得判断下是否有输赢，或者平局。大致的思路就是这样，现在我们来开始实现代码。<br>
我们首先先在vs编译器上创建一个项目，创建一个test.c源文件，用作测试；一个game.c源文件，用于代码的具体实现；一个game.h头文件，用于函数的声明。大概是这样：<br>
<img src="https://zht88821.github.io/post-images/1620911963182.png" alt="" loading="lazy"><br>
我们要写test.c文件，把整个程序的执行流程写下来：<br>
<img src="https://zht88821.github.io/post-images/1620912080449.png" alt="" loading="lazy"><br>
封装了一个test（）函数，test()函数的实现为：<br>
<img src="https://zht88821.github.io/post-images/1620912148392.png" alt="" loading="lazy"><br>
先进入游戏，先打印菜单，封装一个菜单函数：<br>
<img src="https://zht88821.github.io/post-images/1620912332321.png" alt="" loading="lazy"><br>
接下来就进入游戏流程了，输入1，进入游戏：<br>
<img src="https://zht88821.github.io/post-images/1620912601654.png" alt="" loading="lazy"><br>
游戏的流程在图片中说明了，其中封装的函数在game.h头文件中也声明了<br>
<img src="https://zht88821.github.io/post-images/1620913024438.png" alt="" loading="lazy"><br>
函数的大概意思也注释了，还定义两个常量ROW、COL，方便棋盘大小的更改，引入三个头文件会在后面用到。InitBoard()函数的实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620913254665.png" alt="" loading="lazy"><br>
DisplayBoard()函数的实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620913323916.png" alt="" loading="lazy"><br>
井字棋的打印的要点是分组将数据行和分割行循环打印大概这样分组：<br>
<img src="https://zht88821.github.io/post-images/1620914323338.png" alt="" loading="lazy"><br>
就这样打印一行数据，打印一行分割行，再设置条件每行数据和分割行的最后一个竖杠不用打印，而且分割行只需打印row-1行。数据行相当于:   |   |   |,最后一个|不用打；分割行相当于:---|---|---|,同理最后一个|不用打，这样就好设置条件完成棋盘的打印了。<br>
PlayerMove函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620973958678.png" alt="" loading="lazy"><br>
大致就是判断输入的坐标是否合法，合法的话就存在数组里。<br>
ComputerMove函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620974287867.png" alt="" loading="lazy"><br>
用rand()函数实现电脑随机走棋。<br>
每次玩家或者电脑走完棋之后还要判断下游戏的状态，封装了IsWin函数，实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620974610165.png" alt="" loading="lazy"><br>
判断横三行，竖三行和两个对角线是否相等且不为空，如果没有就判断棋盘是否满了，封装了一个IsFull函数实现如图：<br>
<img src="https://zht88821.github.io/post-images/1620974949634.png" alt="" loading="lazy"><br>
如果都不满足，则继续游戏。<br>
游戏运行结果如下：<br>
玩家赢的情况：<br>
<img src="https://zht88821.github.io/post-images/1620976259624.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620976267423.png" alt="" loading="lazy"><br>
电脑赢的情况：<br>
<img src="https://zht88821.github.io/post-images/1620976495695.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620976503782.png" alt="" loading="lazy"><br>
平局的情况:<br>
<img src="https://zht88821.github.io/post-images/1620976820759.png" alt="" loading="lazy"><br>
<img src="https://zht88821.github.io/post-images/1620976833394.png" alt="" loading="lazy"></p>
<p>这个游戏的讲解到这里了，具体的代码实现到我的github上有：https://github.com/zht88821/C_CODE，希望能帮到大家！😀</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言-数组-冒泡排序及数组传参的用法]]></title>
        <id>https://zht88821.github.io/post/c-yu-yan-shu-zu-mou-pao-pai-xu-ji-shu-zu-chuan-can-de-yong-fa/</id>
        <link href="https://zht88821.github.io/post/c-yu-yan-shu-zu-mou-pao-pai-xu-ji-shu-zu-chuan-can-de-yong-fa/">
        </link>
        <updated>2021-05-10T09:03:41.000Z</updated>
        <content type="html"><![CDATA[<p>在学习了数组的有关知识后，和B站教学视频一起码了个冒泡排序，啥是冒泡排序呢？很简单，就是将一个数组按照升/降序排列，很简单的一个小问题，直接上代码：<br>
<img src="https://zht88821.github.io/post-images/1620638475146.png" alt="" loading="lazy"><br>
在代码里定义了一个bubble_sort函数，这里是用来将数组按升序排序的，数组的个数sz的计算之所以不能在函数中，是因为数组名传参只是传过去首元素的地址，在函数中使用sizeof运算符不能计算出正确的数组个数，所以在   main函数中提前将sz算出，然后作为函数参数输入，这里继续提一句，一般来说数组名传参代表首元素的地址，但有两种特殊情况：①在sizeof(数组名)的时候，数组名代表整个数组；②&amp;数组名 代表的是整个数组的地址。<br>
函数中设置了flag，防止在数组已经有序的情况下，进行多余的运算。<br>
此代码的运行结果：<br>
<img src="https://zht88821.github.io/post-images/1620638127505.png" alt="" loading="lazy"><br>
冒泡排序啰嗦到这了，希望能帮到大家！😁</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[小青蛙跳台阶问题的心得]]></title>
        <id>https://zht88821.github.io/post/xiao-qing-wa-tiao-tai-jie-wen-ti-de-xin-de/</id>
        <link href="https://zht88821.github.io/post/xiao-qing-wa-tiao-tai-jie-wen-ti-de-xin-de/">
        </link>
        <updated>2021-05-08T13:50:57.000Z</updated>
        <content type="html"><![CDATA[<p>今天简单研究了下小青蛙问题，类似于斐波那契数列，废话不多说，现在来总结一下这个问题！<br>
我把小青蛙问题分成成两个模块，一个是简单版，一个是进阶版，我们先来讲讲简单版本的小青蛙问题：有一只小青蛙一次能跳1个台阶或者2个台阶，如果台阶一共有n个，问小青蛙总共有多少种跳法？ 先从最简单的问题入手，如果n=1的时候，，小青蛙一共只能选择（1）这1种跳法，如果n=2的时候，小青蛙可以选择（1,1）或者（2）这2种跳法，那么n=3的时候，小青蛙可以选择（1,1,1）、（1,2）、（2,1）3种跳法，n=4的时候可以选择（1,1,1,1)、（1,1,2)、(1,2,1)、(2,2)、(2,1,1)五种，为了方便理解，我们把小青蛙问题看成一个函数：f(n)=n级台阶小青蛙能够选择的跳法总数，根据前面简单列举的几种情况，能发现一点简单的规律，比如：f(3)=f(2)+f(1)、f(4)=f(3)+f(2)。但是研究问题是要严谨的，不能这么随意的就下结论，我们来继续研究一下，当n很大的时候，最后一步无非就只有两种情况：最后一步还剩下1个台阶或者最后一步还剩下2个台阶。  把问题想到这里，就感觉豁然开朗了，最后一步剩下1个台阶的方法数就是f(n-1)，最后一步剩下2个台阶的方法数就是f(n-2),那么就得出我们的推论：      f(n)=f(n-1)+f(n-2),事实上的定论和我们的推论是一样的，在知道了原理，现在我们可以来开始用C语言实现这个问题啦！<br>
<img src="https://zht88821.github.io/post-images/1620482199987.png" alt="" loading="lazy"><br>
在图中jump1函数是用函数递归的方式实现这个问题的，已知最简单的n=1和n=2的时候直接返回种类，将n =1和 n=2设置为递归的出口，在n&gt;2的时候用了公式f(n)=f(n-1)+f(n-2),实现了这个游戏，但是用函数递归的方法可以发现，f(n)=f(n-1)+f(n-2) , 其中的f(n-1)递归成f(n-2)+f(n-3), 其中的f(n-2)又递归成f(n-3)+f(n-4)，可以发现计算中需要大量重复计算相同的值，计算存在大量的冗余，当n的值非常大时 ，计算的效率很低很低，那有什么办法解决呢？<br>
解决办法就是图中的jump2函数，用循环方式解决了计算的大量冗余，使计算不存在冗余，大大提高计算速度。for循环中运用了三个整形变量a,b,c，当n = 1时直接输出1种，当n&gt;=2时，使a+b的值赋给c，b赋给a,c赋给b，循环往复，实现了数值的变化，跳出for循环后在最后返回c。当n=6的时候程序的运行结果如下：<br>
<img src="https://zht88821.github.io/post-images/1620482341731.png" alt="" loading="lazy"><br>
此时小青蛙问题的简易版就解决啦，接下来可以挑战进阶版了😀<br>
那么什么是小青蛙问题的进阶版呢？就是把问题稍微改一下，假设有n个台阶，小青蛙现在可以一次跳1个台阶、一次跳2个台阶、一次跳3个台阶...一次跳n个台阶，请问小青蛙共有多少种跳法呢？是不是感觉难一点了呢，把这个问题弄懂，小青蛙问题应该就没问题了吧，现在我们来讨论一下这个问题？<br>
如果是这样，那么一共有多少种跳法呢？其实思路和简单版的一样，我们可以在最后一步剩余不同的台阶个数，在跳到最后一步只剩余一格的时候，最后一步留有一格的情况下有f(n-1)种，类似的在最后一步只剩余两格的时候有f(n-2种，以此类推，所以f(n)=f(n-1)+f(n-2)+....+f(1)+1,加1是因为可以直接一步跳完，我们又可以发现f(n-1)=f(n-2)+f(n-3)+...+f(1)+1, 所以f(n) = 2*f(n-1)，在理清了思路后我们就可以用C语言来实现啦！下面是C语言实现：<br>
<img src="https://zht88821.github.io/post-images/1620483876997.png" alt="" loading="lazy"><br>
函数jump_adv就是解决进阶版问题的函数了，这里直接用循环方式了，不写递归方式了，因为循环方式比递归方式更优，函数里设置了整形变量sum和a，sum用来计算公式f(n)=f(n-1)+f(n-2)+...+f(1)+1的累加和，a是初始值，sum将即将改变的值赋给a和sum每次加上新的a的值实现函数，详细的解析写在图片里了。当n=6时，程序执行的结果如下：<br>
<img src="https://zht88821.github.io/post-images/1620484153734.png" alt="" loading="lazy"><br>
到现在为止，小青蛙跳台阶的问题算是讲清楚了，如果能帮到你，那是我的荣幸，很高兴分享自己的心得😋！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[汉诺塔游戏的心得]]></title>
        <id>https://zht88821.github.io/post/han-nuo-ta-you-xi-de-xin-de/</id>
        <link href="https://zht88821.github.io/post/han-nuo-ta-you-xi-de-xin-de/">
        </link>
        <updated>2021-05-07T13:52:04.000Z</updated>
        <content type="html"><![CDATA[<p>从昨天到现在的碎片时间研究了下汉诺塔游戏的c语言实现，看到鹏哥c语言中提到了这个，就来试着自己学一学，刚学到递归调用，汉诺塔也算是一个递归调用的经典例题，刚好来巩固一下所学的知识，一开始谷歌了下网上的文档，内容不怎么容易懂，没怎么搞清楚，然后在B站找了个视频看，现在终于弄得差不多懂了，来分享一下自己的想法。<br>
先来简单介绍一下汉诺塔游戏，我直接谷歌了一下简介：汉诺塔（Tower of Hanoi），又称河内塔，是一个源于印度古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。简单来说就是有三根柱子A、B、C,在A上有若干个从下往上逐渐变小的圆盘，要从柱子A借助柱子B转移到柱子C，规则就是：①一次只能转移一个圆盘。②较大的圆盘不能放在较小的圆盘上。<img src="https://zht88821.github.io/post-images/1620396589941.jfif" alt="" loading="lazy">  如果只是让你直接操作应该也不算难，如果在c语言上实现呢?<br>
这个游戏算法在c语言中实现需要用到函数递归，要用到递归，那么首先需要把一个大的问题分解成一个小的步骤，然后能重复调用这个步骤接近结果，直到执行结束。<img src="https://zht88821.github.io/post-images/1620396955102.png" alt="" loading="lazy">分解步骤我在B站看的视频里已经写的很明白了，我就直接借用这张图来描述了。图中把整个过程分成了三步，其中第一步和第三步又可以各自看成一次汉诺塔游戏，递归调用重复这三个步骤，递归的出口就是只剩下一个盘子的时候把最后一个盘子移到目的杆子上。<br>
借助这个思想，就可以在编译器上来实现<img src="https://zht88821.github.io/post-images/1620397429887.png" alt="" loading="lazy"><br>
假设有3个盘子的时候，程序的执行结果：<img src="https://zht88821.github.io/post-images/1620397541028.png" alt="" loading="lazy"><br>
汉诺塔游戏的心得到这里了，如果能帮到大家，是我的荣幸😀！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World!!!]]></title>
        <id>https://zht88821.github.io/post/hello-world/</id>
        <link href="https://zht88821.github.io/post/hello-world/">
        </link>
        <updated>2021-04-29T10:07:24.000Z</updated>
        <content type="html"><![CDATA[<p>忙活了几天终于把属于自己的博客创建起来了😋，也是我第一次写博客，作为未来的IT新星，我会在这里分享我学习的经验，希望能和大家一起交流学习，能一起进步！😀 顺便记录下自己成长的历程和阶段，希望成为一个非常厉害的程序员，希望能赚大钱，加油！ 千里之行始于足下，每天的积累至关重要，坚持学习将是我最厉害的武器！</p>
]]></content>
    </entry>
</feed>